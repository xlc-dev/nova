#!/bin/sh

# -----------------------------------------------------------------------------
# fssg - Fast, Simple Static Site Generator
# -----------------------------------------------------------------------------
#
# Overview:
#   fssg is a portable, dependency-free static site generator written entirely
#   in POSIX shell and AWK. It recursively processes Markdown (.md) and .html
#   files in `src/` and outputs a minified, deployable website in `dist/`.
#
# Key Features:
#   - Converts Markdown into clean HTML using a built‑in AWK parser.
#   - Supports includes (`src/includes/`) and include-blocks with parameters.
#   - Handles template logic and conditionals:
#   -   {{IF_PAGE:page.html}} ... {{ELSE_PAGE}} ... {{ENDIF_PAGE}}
#   -   {{IF_EXT:md}} ... {{ELSE_EXT}} ... {{ENDIF_EXT}}
#   - Applies a site‑wide layout (src/template.html) via {{content}} injection.
#   - Hoists and consolidates <style> and <script> blocks automatically.
#   - Set the title of a page via {{title: My Page}} with {{title}} injection.
#   - Copies static assets from `src/static` -> `dist/static/`.
#   - Optional live‑reload and local dev server with `--serve`/`--watch`.
#   - Parallel build support with `--jobs <num>`.
#
# Usage:
#   ./fssg [options]
#
# Common Options:
#   -h, --help        Show help text and exit.
#   -V, --version     Show version information.
#   -q, --quiet       Suppress informational output (errors still shown).
#   -v, --verbose     Enable extensive debug logging.
#   -n, --nocolor     Disable colored terminal output.
#
# Development & Build:
#   -w, --watch       Rebuild automatically when `src/` changes.
#   -s, --serve       Start a local web server (default port: 8000).
#   -o, --open        Open default web browser when serving (requires --serve).
#   -j, --jobs <num>  Number of parallel build jobs (default: 100).
#   -m, --minify      Disable HTML minification (useful for debugging).
#
# Environment Variables:
#   FSSG_BASE_URL     Base URL for the website.
#   FSSG_SERVER_CMD   Override the server command for --serve.
#                     Example: FSSG_SERVER_CMD="(cd dist && python3 -m http.server 9000)"
#   FSSG_SERVER_PORT  Port used by internal server (default: 8000).
#   FSSG_AWK          Custom command for the awk executable (default: awk).
#   FSSG_AWK_OPTS     Custom options for the awk executable (default: none).
#
# License: MIT License (see below)
#
# Author:  xlc-dev
# URL:     https://github.com/xlc-dev/fssg
#
# Copyright (c) xlc-dev 2025
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -----------------------------------------------------------------------------

# Global Configuration
VERSION="1.3.1"
QUIET=0
VERBOSE=0
MAX_JOBS=100
WATCH=0
SERVE=0
OPEN_BROWSER=0
NO_COLOR=0
MINIFY=1
FSSG_SERVER_PORT=${FSSG_SERVER_PORT:-8000}
FSSG_BASE_URL=${FSSG_BASE_URL:-}
FSSG_AWK=${FSSG_AWK:-awk}
FSSG_AWK_OPTS=${FSSG_AWK_OPTS:-}

# Runtime State
SERVER_PID=""
SCRIPT_PATH="$0"
AWK_CMD="$FSSG_AWK $FSSG_AWK_OPTS"

# Logger functions with standardized output
log_info() { [ "$QUIET" -eq 0 ] && printf '%s[INFO]%s %s\n' "$GREEN" "$NC" "$1"; }
log_verbose() { [ "$VERBOSE" -eq 1 ] && printf '%s[DEBUG]%s %s\n' "$BLUE" "$NC" "$1"; }
log_warn() { [ "$QUIET" -eq 0 ] && printf '%s[WARN]%s %s\n' "$YELLOW" "$NC" "$1" >&2; }
log_error() { printf '%s[ERROR]%s %s\n' "$RED" "$NC" "$1" >&2; }
fatal() { log_error "$1" && exit 1; }

# Resolve to script directory
case "$SCRIPT_PATH" in
/*) SCRIPT_DIR=$(dirname "$SCRIPT_PATH") ;;
*/*) SCRIPT_DIR=$(
  cd "$(dirname "$SCRIPT_PATH")" || exit 1
  pwd
) ;;
*) SCRIPT_DIR=$(pwd) ;;
esac
cd "$SCRIPT_DIR" || fatal "Failed to switch to script directory: $SCRIPT_DIR"

# Absolute path to this script
SCRIPT_PATH="$SCRIPT_DIR/$(basename "$SCRIPT_PATH")"

# Check for AWK program
AWK_PROG=${FSSG_AWK%% *}
if ! command -v "$AWK_PROG" >/dev/null 2>&1; then
  fatal "'$AWK_PROG' not found. Please install it and try again."
fi

# Cleanup function for trap on exit
cleanup() {
  # Stop the server if it's running
  if [ -n "$SERVER_PID" ]; then
    log_verbose "Stopping server (PID: $SERVER_PID)..."
    kill "$SERVER_PID" 2>/dev/null || true
  fi
}

# Wait for background jobs to finish and capture non-zero exits
wait_for_pids() {
  err=0
  if [ -z "$pids" ]; then return 0; fi
  for pid in $pids; do
    # wait returns 127 when the pid is not a child (already reaped / not ours).
    # Treat 127 as non-fatal; treat other non-zero exit codes as failures.
    wait "$pid"
    rc=$?
    if [ "$rc" -eq 127 ]; then
      log_verbose "PID $pid not a child (already reaped); ignoring."
      continue
    fi
    if [ "$rc" -ne 0 ]; then
      log_verbose "PID $pid failed (exit $rc)."
      err=1
    fi
  done
  return $err
}

# Parses Markdown to HTML using an embedded AWK script
parse_markdown() {
  script=$(
    cat <<'EOF'
    BEGIN{list_depth=0;in_code=0;in_table=0;in_thead=0;in_tbody=0;in_bq=0;in_para=0;in_script=0;in_style=0;in_html_block=0}
    function close_para(){if(in_para){print"</p>";in_para=0}}
    function open_list(t,i){list_depth++;list_type[list_depth]=t;list_indent[list_depth]=i;print"<"t">"}
    function close_list(){print"</"list_type[list_depth]">";delete list_type[list_depth];delete list_indent[list_depth];list_depth--}
    function close_lists_to(i){while(list_depth>0&&list_indent[list_depth]>=i)close_list()}
    function handle_list(t,i){while(list_depth>0&&(list_indent[list_depth]>i||(list_indent[list_depth]==i&&list_type[list_depth]!=t)))close_list();if(list_depth==0||list_indent[list_depth]<i)open_list(t,i)}
    function close_blocks(){if(in_table){if(in_tbody)print"</tbody>";else if(in_thead)print"</thead>";print"</table>";in_table=in_thead=in_tbody=0}}
    function is_block_html(l){return l~/^[[:space:]]*<(div|header|footer|nav|section|article|aside|main|form|table|ul|ol|dl|pre|blockquote|h[1-6]|p|hr|address|fieldset|figure)[[:space:]>\/]/}
    function is_closing_html(l){return l~/^[[:space:]]*<\//}
    function generate_id(t){id=tolower(t);gsub(/[^a-z0-9 -]/,"",id);gsub(/[[:space:]]+/,"-",id);gsub(/-+/,"-",id);gsub(/^-|-$/,"",id);return id}
    function process_inline(t,pre,post,m,a,b,c,rep,codes,cc,i,ph,pos){
      gsub(/\\\\/,"\x01",t);gsub(/\\\*/,"\x02",t);gsub(/\\_/,"\x03",t);gsub(/\\`/,"\x04",t);gsub(/\\\[/,"\x05",t);gsub(/\\\]/,"\x06",t);gsub(/\\\(/,"\x07",t);gsub(/\\\)/,"\x08",t);gsub(/\\#/,"\x09",t);gsub(/\\\+/,"\x0A",t);gsub(/\\-/,"\x0B",t);gsub(/\\./,"\x0C",t);gsub(/\\!/,"\x0D",t);gsub(/\\\|/,"\x0E",t);
      cc=0;while(match(t,/`[^`]+`/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,2,length(m)-2);gsub(/&/,"\\&amp;",b);gsub(/</,"\\&lt;",b);gsub(/>/,"\\&gt;",b);gsub(/"/,"\\&quot;",b);cc++;codes[cc]=b;ph="\x10"cc"\x11";t=pre ph post}
      while(match(t,/!\[[^]]*\]\([^)]+\)/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);a=index(m,"](");b=substr(m,3,a-3);c=substr(m,a+2,length(m)-a-2);rep=sprintf("<img src=\"%s\" alt=\"%s\">",c,b);t=pre rep post}
      while(match(t,/\[[^]]+\]\([^)]+\)/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);a=index(m,"](");b=substr(m,2,a-2);c=substr(m,a+2,length(m)-a-2);rep=sprintf("<a href=\"%s\">%s</a>",c,b);t=pre rep post}
      while(match(t,/\*\*\*[^\*]+\*\*\*/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,4,length(m)-6);rep="<strong><em>"b"</em></strong>";t=pre rep post}
      while(match(t,/___[^_]+___/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,4,length(m)-6);rep="<strong><em>"b"</em></strong>";t=pre rep post}
      while(match(t,/\*\*[^\*]+\*\*/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,3,length(m)-4);rep="<strong>"b"</strong>";t=pre rep post}
      while(match(t,/__[^_]+__/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,3,length(m)-4);rep="<strong>"b"</strong>";t=pre rep post}
      while(match(t,/\*[^\*]+\*/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,2,length(m)-2);rep="<em>"b"</em>";t=pre rep post}
      while(match(t,/_[^_]+_/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,2,length(m)-2);rep="<em>"b"</em>";t=pre rep post}
      while(match(t,/~~[^~]+~~/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,3,length(m)-4);rep="<del>"b"</del>";t=pre rep post}
      for(i=1;i<=cc;i++){ph="\x10"i"\x11";while((pos=index(t,ph))>0){t=substr(t,1,pos-1)"<code>"codes[i]"</code>"substr(t,pos+length(ph))}}
      gsub(/\x01/,"\\",t);gsub(/\x02/,"*",t);gsub(/\x03/,"_",t);gsub(/\x04/,"`",t);gsub(/\x05/,"[",t);gsub(/\x06/,"]",t);gsub(/\x07/,"(",t);gsub(/\x08/,")",t);gsub(/\x09/,"#",t);gsub(/\x0A/,"+",t);gsub(/\x0B/,"-",t);gsub(/\x0C/,",",t);gsub(/\x0D/,"!",t);gsub(/\x0E/,"|",t);
      return t
    }
    !in_code&&/^[[:space:]]*<[Ss][Cc][Rr][Ii][Pp][Tt]/{if(!in_script){close_para();close_blocks();close_lists_to(0)}in_script=1}
    !in_code&&/^[[:space:]]*<[Ss][Tt][Yy][Ll][Ee]/{if(!in_style){close_para();close_blocks();close_lists_to(0)}in_style=1}
    in_script||in_style{print;if(in_script&&/<\/[Ss][Cc][Rr][Ii][Pp][Tt]>/)in_script=0;if(in_style&&/<\/[Ss][Tt][Yy][Ll][Ee]>/)in_style=0;next}
    /^[[:space:]]*```/{if(in_code){print "</code></pre>";in_code=0}else{close_para();close_blocks();close_lists_to(0);line=$0;sub(/^[[:space:]]*```[[:space:]]*/,"",line);lang=line;sub(/[[:space:]]*$/,"",lang);if(lang!="")printf "<pre><code class=\"language-"lang"\">";else printf "<pre><code>";in_code=1}next}
    in_code{gsub(/&/,"\\&amp;",$0);gsub(/</,"\\&lt;",$0);gsub(/>,"\\&gt;",$0);print;next}
    in_html_block{print;if(is_closing_html($0))in_html_block=0;next}
    is_block_html($0){close_para();close_blocks();close_lists_to(0);print;if($0!~/<\/(div|header|footer|nav|section|article|aside|main|form|table|ul|ol|dl|pre|blockquote|h[1-6]|p|hr|address|fieldset|figure)>/)in_html_block=1;next}
    /^[[:space:]]*$/{close_para();close_blocks();if(in_bq){print"</blockquote>";in_bq=0};next}
    /^#{1,6}[[:space:]]/{close_para();close_blocks();close_lists_to(0);n=0;while(substr($0,1,1)=="#"){n++;$0=substr($0,2)};sub(/^[[:space:]]*/,"",$0);id=generate_id($0);printf "<h%d id=\"%s\">%s</h%d>\n",n,id,process_inline($0),n;next}
    /^[[:space:]]*([-*_][[:space:]]*){3,}$/{close_para();close_blocks();close_lists_to(0);print"<hr>";next}
    /^[[:space:]]*>/{close_para();if(!in_bq){close_blocks();close_lists_to(0);print"<blockquote>";in_bq=1};line=$0;sub(/^[[:space:]]*>[[:space:]]*/,"",line);print"<p>"process_inline(line)"</p>";next}
    /^[[:space:]]*[-*+][[:space:]]+/{match($0,/^[ \t]*/);indent=RLENGTH;close_para();close_blocks();handle_list("ul",indent);sub(/^[[:space:]]*[-*+][[:space:]]*/,"",$0);print"<li>"process_inline($0)"</li>";next}
    /^[[:space:]]*[0-9]+\.[[:space:]]+/{match($0,/^[ \t]*/);indent=RLENGTH;close_para();close_blocks();handle_list("ol",indent);sub(/^[[:space:]]*[0-9]+\.[[:space:]]*/,"",$0);print"<li>"process_inline($0)"</li>";next}
    /^[[:space:]]*\|/{close_para();line=$0;sub(/^[[:space:]]*\|/,"",line);sub(/\|\s*$/,"",line);n=split(line,cols,/\|/);sep="^[[:space:]]*:?-+:?[[:space:]]*$";is_sep=1;for(i=1;i<=n;i++)if(cols[i]!~sep)is_sep=0;if(!in_table){close_blocks();close_lists_to(0);print"<table><thead>";in_table=1;in_thead=1;delete align}if(is_sep){for(i=1;i<=n;i++){cell=cols[i];gsub(/^[[:space:]]+|[[:space:]]+$/,"",cell);if(cell~/^:[^-]*-+[^-]*:$/)align[i]="center";else if(cell~/^:[^-]*-+$/)align[i]="left";else if(cell~/^-+[^-]*:$/)align[i]="right";else align[i]=""}print"</thead>\n<tbody>";in_thead=0;in_tbody=1;next}printf"<tr>";for(i=1;i<=n;i++){cell=process_inline(cols[i]);tag=in_thead?"th":"td";if(align[i]!="")printf"<%s align=\"%s\">%s</%s>",tag,align[i],cell,tag;else printf"<%s>%s</%s>",tag,cell,tag}print"</tr>";next}
    {if(in_bq&&$0!~/^[[:space:]]*>/){print"</blockquote>";in_bq=0};close_lists_to(0);close_blocks();if($0~/^[[:space:]]*</){close_para();print}else if($0~/[^[:space:]]/){if(!in_para){printf"<p>%s",process_inline($0);in_para=1}else{printf" %s",process_inline($0)}}}
    END{close_blocks();close_lists_to(0);close_para();if(in_bq)print"</blockquote>";if(in_code)print"</code></pre>";printf"\n"}
EOF
  )
  $AWK_CMD "$script"
}

# Processes templates, conditionals, and includes
run_template_processor() {
  _title="$1"
  _page="$2"
  _ext="$3"

  shift 3

  script=$(
    cat <<'EOF'
      BEGIN{content_c=0;cond_depth=0;print_ok[0]=1;branch_taken[0]=0;block="";inc_filename="";markdown_flag=0;state="NORMAL"}
      function ac(line,i,out,pos,rest){
        out=""; rest=line
        while((pos=index(rest,"{{content}}"))>0){
          out=out substr(rest,1,pos-1)
          for(i=1;i<=content_c;i++) out=out content[i] "\n"
          rest=substr(rest,pos+length("{{content}}"))
        }
        rest=out rest; out=""
        while(match(rest,/\{\{[[:space:]]*content[[:space:]]*\}\}/)){
          out=out substr(rest,1,RSTART-1)
          for(i=1;i<=content_c;i++) out=out content[i] "\n"
          rest=substr(rest,RSTART+RLENGTH)
        }
        print out rest
      }
      function trim(s){gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s}
      function cn(t){gsub(/\n|[[:space:]]+/," ",t); return trim(t)}
      function pc(tag,tn,type,target,current_val,is_met,can_take){
        tn=cn(tag)
        if(tn~/^\{\{[[:space:]]*IF_(EXT|PAGE):/){
          cond_depth++; type=(tn~/IF_EXT:/)?"EXT":"PAGE"
          sub(/^\{\{[[:space:]]*IF_(EXT|PAGE):/,"",tn); sub(/\}\}.*/,"",tn)
          target=trim(tn); current_val=(type=="EXT")?current_ext:current_page
          is_met=(target==current_val)
          print_ok[cond_depth]=print_ok[cond_depth-1]&&is_met
          branch_taken[cond_depth]=print_ok[cond_depth]?1:0; return 1
        } else if(tn~/^\{\{[[:space:]]*ELIF_(EXT|PAGE):/){
          type=(tn~/ELIF_EXT:/)?"EXT":"PAGE"
          sub(/^\{\{[[:space:]]*ELIF_(EXT|PAGE):/,"",tn); sub(/\}\}.*/,"",tn)
          target=trim(tn); current_val=(type=="EXT")?current_ext:current_page
          can_take=print_ok[cond_depth-1]&&!branch_taken[cond_depth]; is_met=(target==current_val)
          print_ok[cond_depth]=can_take&&is_met; if(print_ok[cond_depth]) branch_taken[cond_depth]=1; return 1
        } else if(tn~/^\{\{[[:space:]]*ELSE_(EXT|PAGE)/){
          can_take=print_ok[cond_depth-1]&&!branch_taken[cond_depth]
          print_ok[cond_depth]=can_take; if(can_take) branch_taken[cond_depth]=1; return 1
        } else if(tn~/^\{\{[[:space:]]*ENDIF_(EXT|PAGE)/){ cond_depth--; return 1 }
        return 0
      }
      function it(s){gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s}
      function lt(fp,arr,n,line){n=0; while((getline line<fp)>0) arr[++n]=line; close(fp); return n}
      function rd(arr,n,params,block,i,key,line,rest,p,out){
        for(i=1;i<=n;i++){
          line=arr[i]; for(key in params) gsub("{{"key"}}",params[key],line)
          rest=line; out=""
          while((p=index(rest,"{{content}}"))>0){ out=out substr(rest,1,p-1) block; rest=substr(rest,p+length("{{content}}")) }
          print out rest
        }
      }
      function pt(full,s,ps,key,val,eq,vs,qc,off){
        s=it(full); gsub(/\n/," ",s); sub(/^.*include-block[[:space:]]*:/,"",s); sub(/\}\}.*/,"",s); s=it(s)
        if(match(s,/^[^[:space:]]+/)){ inc_filename=substr(s,RSTART,RLENGTH); ps=it(substr(s,RSTART+RLENGTH)) } else { inc_filename=""; ps="" }
        delete params; markdown_flag=0
        while(ps){
          eq=index(ps,"="); if(eq<=1) break
          key=it(substr(ps,1,eq-1)); qc=substr(ps,eq+1,1)
          if(qc!="\"" && qc!="\047"){
            if(match(substr(ps,eq+1),/[[:space:]]+/)){ val=substr(ps,eq+1,RSTART-1); ps=it(substr(ps,eq+1+RLENGTH)) } else { val=substr(ps,eq+1); ps="" }
          } else {
            vs=eq+2; off=index(substr(ps,vs),qc); if(!off) break; val=substr(ps,vs,off-1); ps=it(substr(ps,vs+off))
          }
          params[key]=val; if(key=="markdown" && (val=="true" || val=="1")) markdown_flag=1
        }
      }
      function pl(line,rest,match_pos,before,directive,norm,f,fname,p,il){
        rest=line
        while(rest!=""){
          match_pos=match(rest,/\{\{[[:space:]]*(IF_|ELIF_|ELSE_|ENDIF_|include-block:|include:)/)
          if(match_pos==0){ if(print_ok[cond_depth]) ac(rest); return }
          before=substr(rest,1,match_pos-1); if(before!"" && print_ok[cond_depth]) ac(before)
          directive=substr(rest,match_pos); if(!match(directive,/\}\}/)){ if(print_ok[cond_depth]) ac(directive); return }
          directive=substr(directive,1,RSTART+RLENGTH-1); norm=directive; gsub(/\n|[[:space:]]+/," ",norm)
          if(pc(norm)){}
          else if(norm~/\{\{[[:space:]]*include:[^}]+\}\}/){
            if(print_ok[cond_depth]){
              f=norm; sub(/^.*include[[:space:]]*:/,"",f); sub(/\}\}.*/,"",f); fname=it(f); p=INC_DIR"/"fname
              if(system("test -f \""p"\"")==0){ while((getline il<p)>0) print il; close(p) } else print "<!-- include file not found: " fname " -->"
            }
          } else if(norm~/\{\{[[:space:]]*include-block:/){
            if(print_ok[cond_depth]){ pt(norm); state="INCLUDE_BLOCK"; block="" } ; return
          } else { if(print_ok[cond_depth]) print directive }
          rest=substr(rest,match_pos+length(directive))
        }
      }
      FILENAME=="-"{ content[++content_c]=$0; next }
      {
        line=$0; gsub(/\{\{title\}\}/, template_title_value, line)
        gsub(/\{\{[[:space:]]*BASE_URL[[:space:]]*\}\}/, BASE_URL, line)
        if(state=="INCLUDE_BLOCK"){
          if(line~/\{\{[[:space:]]*endinclude/){
            p=INC_DIR"/"inc_filename
            if(system("test -f \"" p "\"")==0){
              tn=lt(p,tpl)
              if(markdown_flag){
                cmd="mktemp"; cmd|getline tmpfile; close(cmd)
                print block > tmpfile; close(tmpfile)
                cmd=SCRIPT_PATH " --_md \"" tmpfile "\""
                block_html=""
                while((cmd|getline bl)>0) block_html = block_html (block_html ? "\n" : "") bl
                close(cmd)
                rd(tpl,tn,params,block_html)
                system("rm -f " tmpfile)
              } else rd(tpl,tn,params,block)
            } else print "<!-- include-block file not found: " inc_filename " -->"
            state="NORMAL"
          } else { block = block (block ? "\n" : "") line }
          next
        }
        if(line~/^[[:space:]]*$/){ if(print_ok[cond_depth]) print line; next }
        pl(line)
      }
EOF
  )
  $AWK_CMD -v template_title_value="$_title" \
    -v current_page="$_page" -v current_ext="$_ext" \
    -v INC_DIR="src/includes" -v pid="$$" -v BASE_URL="${FSSG_BASE_URL}" \
    -v SCRIPT_PATH="$SCRIPT_PATH" "$script" "$@"
}

# Hoists styles and scripts to the end of <head> and <body> respectively
process_styles_and_scripts() {
  script=$(
    cat <<'EOF'
    BEGIN { s=0; b=""; sc=0; tc=0 }
    /<style\b[^>]*>/ { s=1; b=$0; next }
    /<\/style>/ && s==1 { S[++sc] = b RS $0; s=0; b=""; next }
    s==1 { b = b RS $0; next }
    /<script\b[^>]*>/ { s=2; b=$0; next }
    /<\/script>/ && s==2 { T[++tc] = b RS $0; s=0; b=""; next }
    s==2 { b = b RS $0; next }
    /<style\b[^>]*>.*<\/style>/ { S[++sc] = $0; next }
    /<script\b[^>]*>.*<\/script>/ { T[++tc] = $0; next }
    /<\/head>/ {
      for(i=1; i<=sc; i++) print S[i];
      print;
      next
    }
    /<\/body>/ {
      for(i=1; i<=tc; i++) print T[i];
      print;
      next
    }
    { print }
EOF
  )
  $AWK_CMD "$script"
}

# Minifies and writes final HTML, preserving <pre> blocks verbatim.
minify_and_write() {
  out_file="$1"
  if [ "$MINIFY" -eq 0 ]; then
    process_styles_and_scripts >"$out_file"
    return 0
  fi

  script=$(
    cat <<'EOF'
    { buf = buf $0 "\n" }
    function is_ws(c){ return c~/[[:space:]]/ }
    function strip_html_comments(s, out, cs, ce){
      out = ""
      while (1) {
        cs = index(s, "<!--")
        if (cs == 0) { out = out s; break }
        out = out substr(s, 1, cs-1)
        s = substr(s, cs+4)
        ce = index(s, "-->")
        if (ce == 0) break
        s = substr(s, ce+3)
      }
      return out
    }
    function strip_css_js_comments(s, is_js, out, i, L, ch, in_s, sc, in_c, is_line, nx){
      out=""; i=1; L=length(s); in_s=0; sc=""; in_c=0; is_line=0
      while(i<=L){
        ch=substr(s,i,1)
        if(in_c){
          if(is_line && ch=="\n"){ in_c=0; out=out ch; i++; continue }
          if(!is_line && ch=="*" && substr(s,i+1,1)=="/"){ in_c=0; i+=2; continue }
          i++; continue
        }
        if(in_s){ out=out ch; if(ch==sc && substr(s,i-1,1)!="\\") in_s=0; i++; continue }
        if(ch=="\"" || ch==sprintf("%c",39)){ in_s=1; sc=ch; out=out ch; i++; continue }
        if(ch=="/" && i<L){ nx=substr(s,i+1,1)
          if(nx=="*"){ in_c=1; is_line=0; i+=2; continue }
          if(is_js && nx=="/"){ in_c=1; is_line=1; i+=2; continue }
        }
        out=out ch; i++
      }
      return out
    }
    function minify_chunk(s, j, slen, ch, res, tag, k, tch, tlen, iq, qch, pend, m, txt, cleaned){
      s = strip_html_comments(s)
      res=""; j=1; slen=length(s)
      while(j<=slen){
        ch=substr(s,j,1)
        if(ch=="<"){
          tag=""; iq=0; qch=""; k=j
          while(k<=slen){
            tch=substr(s,k,1); tag=tag tch
            if(tch=="\"" || tch==sprintf("%c",39)){
              if(!iq){ iq=1; qch=tch } else if(qch==tch) iq=0
            } else if(tch==">" && !iq){ k++; break }
            k++
          }
          cleaned=""; pend=0; tlen=length(tag); iq=0; qch=""
          for(m=1;m<=tlen;m++){
            tch=substr(tag,m,1)
            if(tch=="\"" || tch==sprintf("%c",39)){
              cleaned = cleaned tch
              if(!iq){ iq=1; qch=tch } else if(qch==tch) iq=0
              pend=0
            } else if(!iq && is_ws(tch)) pend=1
            else {
              if(pend){
                if(length(cleaned)>0 && substr(cleaned,length(cleaned),1)!="<") cleaned = cleaned " "
                pend=0
              }
              cleaned = cleaned tch
            }
          }
          gsub(/<[[:space:]]+/, "<", cleaned); gsub(/[[:space:]]+>/, ">", cleaned)
          res = res cleaned; j = k
        } else {
          p = index(substr(s,j), "<")
          if(p==0){ txt=substr(s,j); j=slen+1 } else { txt=substr(s,j,p-1); j += p-1 }
          gsub(/[[:space:]]+/, " ", txt); res = res txt
        }
      }
      gsub(/>[[:space:]]*</, "><", res); return res
    }
    END{
      n=length(buf); pos=1; out=""
      while(pos<=n){
        rest=substr(buf,pos)
        if(match(rest, /<[Pp][Rr][Ee]([[:space:]>]|$)/)){
          pre_start = pos + RSTART - 1
          if(pre_start>pos) out = out minify_chunk(substr(buf,pos,pre_start-pos))
          rest2 = substr(buf, pre_start)
          if(match(rest2, /<\/[Pp][Rr][Ee][^>]*>/)){
            pre_end = pre_start + RSTART + RLENGTH - 1
            out = out substr(buf, pre_start, pre_end - pre_start + 1); pos = pre_end + 1; continue
          } else { out = out substr(buf, pre_start); break }
        }
        if(match(rest, /<[Ss][Tt][Yy][Ll][Ee]([[:space:]>]|$)/)){
          style_start = pos + RSTART - 1
          if(style_start>pos) out = out minify_chunk(substr(buf,pos,style_start-pos))
          rest2 = substr(buf, style_start)
          if(match(rest2, /<\/[Ss][Tt][Yy][Ll][Ee][^>]*>/)){
            style_end = style_start + RSTART + RLENGTH - 1
            style_block = substr(buf, style_start, style_end - style_start + 1)
            style_block = strip_css_js_comments(style_block, 0)
            out = out style_block; pos = style_end + 1; continue
          }
        }
        if(match(rest, /<[Ss][Cc][Rr][Ii][Pp][Tt]([[:space:]>]|$)/)){
          script_start = pos + RSTART - 1
          if(script_start>pos) out = out minify_chunk(substr(buf,pos,script_start-pos))
          rest2 = substr(buf, script_start)
          if(match(rest2, /<\/[Ss][Cc][Rr][Ii][Pp][Tt][^>]*>/)){
            script_end = script_start + RSTART + RLENGTH - 1
            script_block = substr(buf, script_start, script_end - script_start + 1)
            script_block = strip_css_js_comments(script_block, 1)
            out = out script_block; pos = script_end + 1; continue
          }
        }
        out = out minify_chunk(rest); break
      }
      printf "%s", out
    }
EOF
  )
  process_styles_and_scripts | $AWK_CMD "$script" >"$out_file"
}

# Process a single file from src/ into dist/
process_file() {
  src_file="$1"
  rel_path="${src_file#src/}"
  extension="${src_file##*.}"
  out_file="dist/${rel_path%.*}.html"

  mkdir -p "$(dirname "$out_file")" ||
    {
      log_error "Failed to create directory for $out_file"
      return 1
    }

  base_name=$(basename "$src_file" ."$extension")
  pretty_title=$(
    echo "$base_name" | tr '-' ' ' |
      $AWK_CMD '{for(i=1;i<=NF;i++)$i=toupper(substr($i,1,1))tolower(substr($i,2));}1'
  )
  raw_content=$(cat "$src_file")
  override_title=$(
    echo "$raw_content" 2>/dev/null |
      $AWK_CMD '/\{\{title:/ {sub(/.*\{\{.*:/,"");sub(/\}\}.*/,"");print;exit}'
  )
  final_title="${override_title:-$pretty_title}"

  page_id="${rel_path%.*}.html"
  template_file="src/template.html"
  if ! [ -f "$template_file" ]; then
    log_verbose "No src/template.html found, processing without a layout."
    template_file="/dev/null"
  fi

  # PASS 1: Process file for includes & conditionals.
  content_with_includes=$(
    echo "" | run_template_processor "$final_title" "$page_id" "$extension" \
      - "$src_file"
  )

  # PASS 1b: Process any template directives that came from includes
  # This ensures {{IF_PAGE:}} etc. from include templates are processed
  # before markdown parsing
  if echo "$content_with_includes" 2>/dev/null | grep -q '{{[[:space:]]*[A-Za-z_]'; then
    log_verbose "Processing template directives from includes..."
    tmpfile_directives=$(mktemp)
    echo "$content_with_includes" >"$tmpfile_directives"
    content_directives_processed=$(
      echo "" | run_template_processor "$final_title" "$page_id" "$extension" \
        - "$tmpfile_directives"
    )
    rm -f "$tmpfile_directives"
  else
    content_directives_processed="$content_with_includes"
  fi

  # Check if include-block with markdown=true was used. If so, the content is
  # already HTML and we should skip the main markdown parsing pass.
  # We detect this by checking if the original file had the directive and the
  # output now looks like an HTML document.
  is_pre_rendered_html=0
  if echo "$raw_content" 2>/dev/null | grep 'include-block:[^}]*markdown="true"' >/dev/null &&
    echo "$content_directives_processed" 2>/dev/null | grep -i '<!DOCTYPE.*html\|<!doctype.*html\|<html>' >/dev/null; then
    log_verbose "Detected pre-rendered HTML from include-block; skipping main markdown pass."
    is_pre_rendered_html=1
  fi

  # PASS 2: If the original file was Markdown and it wasn't pre-rendered...
  if [ "$extension" = "md" ] && [ "$is_pre_rendered_html" -eq 0 ]; then
    body_html=$(
      echo "$content_directives_processed" |
        sed 's/{{title:[^}]*}}//g' |
        parse_markdown
    )
  else
    # Otherwise, just remove the title tag and pass through.
    body_html=$(
      echo "$content_directives_processed" |
        sed 's/{{title:[^}]*}}//g'
    )
  fi

  # PASS 3: Inject body into main template only if it wasn't pre-rendered.
  # Pre-rendered content already has its full layout from the include-block.
  if [ "$is_pre_rendered_html" -eq 1 ]; then
    processed_content="$body_html"
  else
    tmp_body_file="$(mktemp)"
    printf '%s\n' "$body_html" >"$tmp_body_file"

    processed_content=$(
      cat "$tmp_body_file" | run_template_processor "$final_title" "$page_id" "$extension" \
        - "$template_file"
    )

    rm -f "$tmp_body_file"
  fi

  # FINAL STEP: Minify, hoist styles/scripts, and write to disk.
  AUTO_RELOAD_SCRIPT='<script>
if (location.hostname==="localhost"||location.hostname==="127.0.0.1"){
 (function checkAutoReload(){
   let last;
   async function poll(){
     try{
       const res=await fetch("/.reload",{cache:"no-store"});
       const text=await res.text();
       if(last && last!==text.trim()){
         console.log("[autoreload] change detected => reload");
         location.reload();
       }
       last=text.trim();
     }catch(e){
       console.warn("[autoreload] error",e);
     }
     setTimeout(poll,2000);
   }
   poll();
 })();
}
</script>'

  if [ "$WATCH" -eq 1 ] || [ "$SERVE" -eq 1 ]; then
    # inject autoreload script before </body>
    processed_content=$(printf '%s\n' "$processed_content" |
      $AWK_CMD -v script="$AUTO_RELOAD_SCRIPT" '
       /<\/body>/ { print script; print; next }
       { print }
     ')
  fi

  echo "$processed_content" | minify_and_write "$out_file"
  log_verbose "Finished: $src_file -> $out_file"
  return 0
}

# Build the full site
build_site() {
  log_info "Starting build..."

  rm -rf dist
  mkdir -p dist/static || fatal "Could not create dist/static directory."

  if [ -d src/static ]; then
    log_verbose "Copying static assets..."
    if ! cp -R src/static/. dist/static/ 2>/dev/null; then
      log_warn "Copying static assets failed. Some files might be missing."
    fi
  fi

  file_list=$(mktemp)
  find src -type f \( -name '*.md' -o -name '*.html' \) \
    ! -path 'src/includes/*' ! -path 'src/static/*' \
    ! -name 'template.html' >"$file_list"

  file_count=$(wc -l <"$file_list" | awk '{print $1}')
  log_info "Found $file_count files to process..."

  BUILD_FAILED=0
  running=0
  processed_count=0
  pids=""

  while IFS= read -r f; do
    (
      log_verbose "Processing: $f"
      if ! process_file "$f"; then
        log_error "Failed to process: $f"
        exit 1
      fi
    ) </dev/null &

    pids="$pids $!"
    running=$((running + 1))
    processed_count=$((processed_count + 1))

    if [ "$running" -ge "$MAX_JOBS" ]; then
      # Wait for the first PID in the list to free up a slot
      wait "$(echo "$pids" | cut -d' ' -f2)"
      # Check its exit code
      rc=$?
      if [ "$rc" -ne 0 ]; then BUILD_FAILED=1; fi
      # Remove it from the list
      pids=$(echo "$pids" | cut -d' ' -f3-)
      running=$((running - 1))
    fi
  done <"$file_list"
  rm -f "$file_list"

  # Wait for all remaining background jobs to finish
  if ! wait_for_pids; then
    BUILD_FAILED=1
  fi

  if [ "$BUILD_FAILED" -eq 0 ]; then
    # Only create the .reload file if watching or serving
    if [ "$WATCH" -eq 1 ] || [ "$SERVE" -eq 1 ]; then
      date +%s >dist/.reload
    fi
    log_info "Build successful! ($processed_count files"
    return 0
  else
    log_error "Build finished with errors. Please check logs above."
    return 1
  fi
}

# Starts a web server
start_server() {
  SERVER_CMD=""

  # Allow overriding the exact server command via env var
  if [ -n "${FSSG_SERVER_CMD:-}" ]; then
    SERVER_CMD="$FSSG_SERVER_CMD"
    log_verbose "Using custom server command: $SERVER_CMD"
  fi

  # If no custom command, prefer a local ./mongoose binary
  if [ -z "$SERVER_CMD" ] && [ -d "./mongoose" ]; then
    log_verbose "Found './mongoose' directory, checking for executables..."
    uname_s=$(uname -s 2>/dev/null || echo "")
    case "$uname_s" in
    Darwin*) CAND="./mongoose/mongoose_macos" ;;
    Linux*) CAND="./mongoose/mongoose_linux" ;;
    CYGWIN* | MINGW* | MSYS*) CAND="./mongoose/mongoose_windows.exe" ;;
    *) CAND="./mongoose/mongoose_linux" ;;
    esac

    if [ -x "$CAND" ]; then
      log_verbose "Using platform-specific local mongoose: $CAND"
      SERVER_CMD="$CAND -d dist/ -v 0"
    else
      # Fallback: find any executable file in the directory
      for f in ./mongoose/*; do
        if [ -x "$f" ]; then
          log_verbose "Using fallback local mongoose: $f"
          SERVER_CMD="$f -d dist/ -v 0"
          break
        fi
      done
    fi
  fi

  # If still no server found, check for system-wide commands
  if [ -z "$SERVER_CMD" ]; then
    if command -v mongoose >/dev/null 2>&1; then
      log_verbose "Found 'mongoose' in PATH, using it to serve."
      SERVER_CMD="mongoose -d dist/ -v 0"
    elif command -v python3 >/dev/null 2>&1; then
      log_verbose "Found 'python3', using its http.server module."
      SERVER_CMD="cd dist && python3 -m http.server $FSSG_SERVER_PORT"
    elif command -v python >/dev/null 2>&1; then
      log_verbose "Found 'python', using its SimpleHTTPServer module."
      SERVER_CMD="cd dist && python -m SimpleHTTPServer $FSSG_SERVER_PORT"
    else
      fatal "No server found. Place mongoose in ./mongoose/, or install mongoose or python3/python system-wide."
    fi
  fi

  log_info "Starting server..."
  # Use sh -c to handle complex commands like 'cd ... && ...' properly
  sh -c "$SERVER_CMD" >/dev/null 2>&1 &
  SERVER_PID=$!

  # Wait briefly for the server to bind to the port and check if it's running
  sleep 0.1
  if ! kill -0 "$SERVER_PID" 2>/dev/null; then
    log_error "Server command failed to start."
    log_error "Command was: $SERVER_CMD"
    fatal "Failed to start development server."
  fi

  log_info "Server started at http://localhost:$FSSG_SERVER_PORT (PID: $SERVER_PID)"
  log_info "Press Ctrl+C to stop."
}

# Opens the default web browser
open_browser() {
  url="http://localhost:${FSSG_SERVER_PORT}"
  log_info "Opening browser at $url"
  case "$(uname -s)" in
  Darwin*) open "$url" >/dev/null 2>&1 & ;;
  Linux*) xdg-open "$url" >/dev/null 2>&1 & ;;
  CYGWIN* | MINGW* | MSYS*) start "$url" >/dev/null 2>&1 & ;;
  *) log_info "Please open the URL above in your browser manually." ;;
  esac
}

# Rebuild files on change
watch_mode() {
  log_info "Initial build for watch mode..."
  if ! build_site; then
    log_warn "Initial build failed. Please fix errors before watching."
  fi

  if [ "${SERVE:-0}" -eq 1 ]; then
    start_server
    [ "${OPEN_BROWSER:-0}" = "1" ] && open_browser
  fi

  log_info "Watching src/ for changes (Press Ctrl+C to stop)..."
  snapshot_checksum() { find src -type f -exec cksum {} \; 2>/dev/null | sort | cksum; }
  prev_sum=$(snapshot_checksum)

  while :; do
    sleep 0.5
    cur_sum=$(snapshot_checksum)
    if [ "$prev_sum" != "$cur_sum" ]; then
      log_info "Change detected, rebuilding..."
      if ! build_site; then
        log_error "Build failed after change. Watch will continue."
      fi
      prev_sum=$cur_sum
    fi
  done
}

# Show help message
display_help() {
  cat <<EOF
fssg - Fast, Simple Static Site Generator (v$VERSION).
-----------------------------------------------------

A POSIX-compliant static site generator using standard shell tools.

Usage:
  $(basename "$0") [options]

Options:
  -h, --help            Display the help message (this text).
  -V, --version         Print the fssg version and exit.
  -q, --quiet           Suppress informational and debug output. Errors are still shown.
  -v, --verbose         Enable verbose debug logging to aid troubleshooting.
  -n, --nocolor         Disable ANSI color sequences in messages.
  -m, --minify          Disables HTML minification. This flag is useful for debugging.

Build & Development:
  -w, --watch           Watch the src/ tree and rebuild automatically on changes.
  -s, --serve           Start a local web server that serves dist/ to localhost:8000 (default).
  -o, --open            Open the default web browser after starting the server. This flag
                        requires -s/--serve to be meaningful.
  -j, --jobs <num>      Number of parallel build jobs (default: 100). Controls how many page
                        conversions run in background concurrently. Accepts a positive number.

Environment Variables:
  FSSG_BASE_URL         Base URL for the website (default: none).
  FSSG_SERVER_CMD       Override the server command used by --serve. Example:
                        FSSG_SERVER_CMD="(cd dist && python3 -m http.server 9000)"
  FSSG_SERVER_PORT      Port used by the internal server (default: 8000).
  FSSG_AWK              Custom command for the awk executable (default: awk).
  FSSG_AWK_OPTS         Custom options for the awk executable (default: none).
EOF
}

# Main script entrypoint
main() {
  # Set up traps for cleanup on exit
  trap 'cleanup' EXIT
  trap 'exit 130' INT TERM HUP

  # Handle internal markdown parsing call
  if [ "${1:-}" = "--_md" ]; then
    if [ -n "$2" ] && [ -f "$2" ]; then
      parse_markdown <"$2"
    else
      parse_markdown
    fi
    exit 0
  fi

  # Parse command line arguments
  while [ $# -gt 0 ]; do
    case "$1" in
    -h | --help)
      display_help
      exit 0
      ;;
    -V | --version)
      echo "fssg version $VERSION"
      exit 0
      ;;
    -q | --quiet)
      QUIET=1
      VERBOSE=0
      shift
      ;;
    -v | --verbose)
      VERBOSE=1
      QUIET=0
      shift
      ;;
    -n | --nocolor)
      NO_COLOR=1
      shift
      ;;
    -w | --watch)
      WATCH=1
      shift
      ;;
    -s | --serve)
      SERVE=1
      shift
      ;;
    -o | --open)
      OPEN_BROWSER=1
      shift
      ;;
    -m | --minify)
      MINIFY=0
      shift
      ;;
    -j | --jobs)
      shift
      case $1 in
      *[!0-9]* | '') fatal "-j/--jobs requires a numeric argument." ;;
      *) MAX_JOBS=$1 ;;
      esac
      shift
      ;;
    --)
      shift
      break
      ;;
    -*) fatal "Unknown option: $1. Use --help for usage info." ;;
    *) break ;;
    esac
  done

  # Set color variables
  if [ "$NO_COLOR" -eq 1 ] || ! [ -t 1 ]; then
    GREEN="" RED="" YELLOW="" BLUE="" NC=""
  else
    GREEN=$(printf '\033[0;32m')
    RED=$(printf '\033[0;31m')
    YELLOW=$(printf '\033[0;33m')
    BLUE=$(printf '\033[0;34m')
    NC=$(printf '\033[0m')
  fi

  if ! [ -d "src" ]; then
    fatal "Source directory 'src' not found. Please create it and add content."
  fi

  if [ "$WATCH" -eq 1 ]; then
    watch_mode
  else
    build_site
    build_status=$?
    if [ "$SERVE" -eq 1 ]; then
      if [ $build_status -ne 0 ]; then
        log_warn "Build failed. Server will not be started."
      else
        start_server
        [ "$OPEN_BROWSER" -eq 1 ] && open_browser
        wait "$SERVER_PID"
      fi
    fi
    exit $build_status
  fi
}

main "$@"
# vim: set tabstop=2 shiftwidth=2 expandtab:
