#!/bin/sh

# -----------------------------------------------------------------------------
# fssg - Fast, Simple Static Site Generator
# -----------------------------------------------------------------------------
#
# Overview:
#   fssg is a portable, dependency-free static site generator written entirely
#   in POSIX shell and AWK. It recursively processes Markdown (.md) and .html
#   files in `src/` and outputs a minified, deployable website in `dist/`.
#
# Key Features:
#   - Converts Markdown into clean HTML using a built‑in AWK parser.
#   - Supports includes (`src/includes/`) and include-blocks with parameters.
#   - Handles template logic and conditionals:
#   -   {{IF_PAGE:page.html}} ... {{ELSE_PAGE}} ... {{ENDIF_PAGE}}
#   -   {{IF_EXT:md}} ... {{ELSE_EXT}} ... {{ENDIF_EXT}}
#   - Applies a site‑wide layout (src/template.html) via {{content}} injection.
#   - Hoists and consolidates <style> and <script> blocks automatically.
#   - Set the title of a page via {{title: My Page}} with {{title}} injection.
#   - Copies static assets from `src/static` -> `dist/static/`.
#   - Optional live‑reload and local dev server with `--serve`/`--watch`.
#   - Parallel build support with `--jobs <num>`.
#
# Usage:
#   ./fssg [options]
#
# Common Options:
#   -h, --help        Show help text and exit.
#   -V, --version     Show version information.
#   -q, --quiet       Suppress informational output (errors still shown).
#   -v, --verbose     Enable extensive debug logging.
#   -n, --nocolor     Disable colored terminal output.
#
# Development & Build:
#   -w, --watch       Rebuild automatically when `src/` changes.
#   -s, --serve       Start a local web server (default port: 8000).
#   -o, --open        Open default web browser when serving (requires --serve).
#   -j, --jobs <num>  Number of parallel build jobs (default: 100).
#   -m, --minify      Disable HTML minification (useful for debugging).
#
# Environment Variables:
#   FSSG_BASE_URL     Base URL for the website.
#   FSSG_SERVER_CMD   Override the server command for --serve.
#                     Example: FSSG_SERVER_CMD="(cd dist && python3 -m http.server 9000)"
#   FSSG_SERVER_PORT  Port used by internal server (default: 8000).
#   FSSG_AWK          Custom command for the awk executable (default: awk).
#   FSSG_AWK_OPTS     Custom options for the awk executable (default: none).
#
# License: MIT License (see below)
#
# Author:  xlc-dev
# URL:     https://github.com/xlc-dev/fssg
#
# Copyright (c) xlc-dev 2025
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -----------------------------------------------------------------------------

# Global Configuration
VERSION="1.3"
QUIET=0
VERBOSE=0
MAX_JOBS=100
WATCH=0
SERVE=0
OPEN_BROWSER=0
NO_COLOR=0
MINIFY=1
FSSG_SERVER_PORT=${FSSG_SERVER_PORT:-8000}
FSSG_BASE_URL=${FSSG_BASE_URL:-}
FSSG_AWK=${FSSG_AWK:-awk}
FSSG_AWK_OPTS=${FSSG_AWK_OPTS:-}

# Runtime State
SERVER_PID=""
SCRIPT_PATH="$0"
AWK_CMD="$FSSG_AWK $FSSG_AWK_OPTS"

# Logger functions with standardized output
log_info() { [ "$QUIET" -eq 0 ] && printf '%s[INFO]%s %s\n' "$GREEN" "$NC" "$1"; }
log_verbose() { [ "$VERBOSE" -eq 1 ] && printf '%s[DEBUG]%s %s\n' "$BLUE" "$NC" "$1"; }
log_warn() { [ "$QUIET" -eq 0 ] && printf '%s[WARN]%s %s\n' "$YELLOW" "$NC" "$1" >&2; }
log_error() { printf '%s[ERROR]%s %s\n' "$RED" "$NC" "$1" >&2; }
fatal() { log_error "$1" && exit 1; }

# Resolve to script directory
case "$SCRIPT_PATH" in
/*) SCRIPT_DIR=$(dirname "$SCRIPT_PATH") ;;
*/*) SCRIPT_DIR=$(
	cd "$(dirname "$SCRIPT_PATH")" || exit 1
	pwd
) ;;
*) SCRIPT_DIR=$(pwd) ;;
esac
cd "$SCRIPT_DIR" || fatal "Failed to switch to script directory: $SCRIPT_DIR"

# Absolute path to this script
SCRIPT_PATH="$SCRIPT_DIR/$(basename "$SCRIPT_PATH")"

# Check for AWK program
AWK_PROG=${FSSG_AWK%% *}
if ! command -v "$AWK_PROG" >/dev/null 2>&1; then
	fatal "'$AWK_PROG' not found. Please install it and try again."
fi

# Cleanup function for trap on exit
cleanup() {
	# Stop the server if it's running
	if [ -n "$SERVER_PID" ]; then
		log_verbose "Stopping server (PID: $SERVER_PID)..."
		kill "$SERVER_PID" 2>/dev/null || true
	fi
}

# Wait for background jobs to finish and capture non-zero exits
wait_for_pids() {
	err=0
	if [ -z "$pids" ]; then return 0; fi
	for pid in $pids; do
		# wait returns 127 when the pid is not a child (already reaped / not ours).
		# Treat 127 as non-fatal; treat other non-zero exit codes as failures.
		wait "$pid"
		rc=$?
		if [ "$rc" -eq 127 ]; then
			log_verbose "PID $pid not a child (already reaped); ignoring."
			continue
		fi
		if [ "$rc" -ne 0 ]; then
			log_verbose "PID $pid failed (exit $rc)."
			err=1
		fi
	done
	return $err
}

# Parses Markdown to HTML using an embedded AWK script
parse_markdown() {
	script=$(
		cat <<'EOF'
    BEGIN{list_depth=0;in_code=0;in_table=0;in_thead=0;in_tbody=0;in_bq=0;in_para=0;in_script=0;in_style=0;in_html_block=0}
    function close_para(){if(in_para){print"</p>";in_para=0}}
    function open_list(t,i){list_depth++;list_type[list_depth]=t;list_indent[list_depth]=i;print"<"t">"}
    function close_list(){print"</"list_type[list_depth]">";delete list_type[list_depth];delete list_indent[list_depth];list_depth--}
    function close_lists_to(i){while(list_depth>0&&list_indent[list_depth]>=i)close_list()}
    function handle_list(t,i){while(list_depth>0&&(list_indent[list_depth]>i||(list_indent[list_depth]==i&&list_type[list_depth]!=t)))close_list();if(list_depth==0||list_indent[list_depth]<i)open_list(t,i)}
    function close_blocks(){if(in_table){if(in_tbody)print"</tbody>";else if(in_thead)print"</thead>";print"</table>";in_table=in_thead=in_tbody=0}}
    function is_block_html(l){return l~/^[[:space:]]*<(div|header|footer|nav|section|article|aside|main|form|table|ul|ol|dl|pre|blockquote|h[1-6]|p|hr|address|fieldset|figure)[[:space:]>\/]/}
    function is_closing_html(l){return l~/^[[:space:]]*<\//}
    function generate_id(t){id=tolower(t);gsub(/[^a-z0-9 -]/,"",id);gsub(/[[:space:]]+/,"-",id);gsub(/-+/,"-",id);gsub(/^-|-$/,"",id);return id}
    function process_inline(t,pre,post,m,a,b,c,rep,codes,cc,i,ph,pos){
      gsub(/\\\\/,"\x01",t);gsub(/\\\*/,"\x02",t);gsub(/\\_/,"\x03",t);gsub(/\\`/,"\x04",t);gsub(/\\\[/,"\x05",t);gsub(/\\\]/,"\x06",t);gsub(/\\\(/,"\x07",t);gsub(/\\\)/,"\x08",t);gsub(/\\#/,"\x09",t);gsub(/\\\+/,"\x0A",t);gsub(/\\-/,"\x0B",t);gsub(/\\./,"\x0C",t);gsub(/\\!/,"\x0D",t);gsub(/\\\|/,"\x0E",t);
      cc=0;while(match(t,/`[^`]+`/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,2,length(m)-2);gsub(/&/,"\\&amp;",b);gsub(/</,"\\&lt;",b);gsub(/>/,"\\&gt;",b);gsub(/"/,"\\&quot;",b);cc++;codes[cc]=b;ph="\x10"cc"\x11";t=pre ph post}
      while(match(t,/!\[[^]]*\]\([^)]+\)/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);a=index(m,"](");b=substr(m,3,a-3);c=substr(m,a+2,length(m)-a-2);rep=sprintf("<img src=\"%s\" alt=\"%s\">",c,b);t=pre rep post}
      while(match(t,/\[[^]]+\]\([^)]+\)/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);a=index(m,"](");b=substr(m,2,a-2);c=substr(m,a+2,length(m)-a-2);rep=sprintf("<a href=\"%s\">%s</a>",c,b);t=pre rep post}
      while(match(t,/\*\*\*[^\*]+\*\*\*/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,4,length(m)-6);rep="<strong><em>"b"</em></strong>";t=pre rep post}
      while(match(t,/___[^_]+___/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,4,length(m)-6);rep="<strong><em>"b"</em></strong>";t=pre rep post}
      while(match(t,/\*\*[^\*]+\*\*/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,3,length(m)-4);rep="<strong>"b"</strong>";t=pre rep post}
      while(match(t,/__[^_]+__/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,3,length(m)-4);rep="<strong>"b"</strong>";t=pre rep post}
      while(match(t,/\*[^\*]+\*/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,2,length(m)-2);rep="<em>"b"</em>";t=pre rep post}
      while(match(t,/_[^_]+_/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,2,length(m)-2);rep="<em>"b"</em>";t=pre rep post}
      while(match(t,/~~[^~]+~~/)){pre=substr(t,1,RSTART-1);m=substr(t,RSTART,RLENGTH);post=substr(t,RSTART+RLENGTH);b=substr(m,3,length(m)-4);rep="<del>"b"</del>";t=pre rep post}
      for(i=1;i<=cc;i++){ph="\x10"i"\x11";while((pos=index(t,ph))>0){t=substr(t,1,pos-1)"<code>"codes[i]"</code>"substr(t,pos+length(ph))}}
      gsub(/\x01/,"\\",t);gsub(/\x02/,"*",t);gsub(/\x03/,"_",t);gsub(/\x04/,"`",t);gsub(/\x05/,"[",t);gsub(/\x06/,"]",t);gsub(/\x07/,"(",t);gsub(/\x08/,")",t);gsub(/\x09/,"#",t);gsub(/\x0A/,"+",t);gsub(/\x0B/,"-",t);gsub(/\x0C/,",",t);gsub(/\x0D/,"!",t);gsub(/\x0E/,"|",t);
      return t
    }
    !in_code&&/^[[:space:]]*<[Ss][Cc][Rr][Ii][Pp][Tt]/{if(!in_script){close_para();close_blocks();close_lists_to(0)}in_script=1}
    !in_code&&/^[[:space:]]*<[Ss][Tt][Yy][Ll][Ee]/{if(!in_style){close_para();close_blocks();close_lists_to(0)}in_style=1}
    in_script||in_style{print;if(in_script&&/<\/[Ss][Cc][Rr][Ii][Pp][Tt]>/)in_script=0;if(in_style&&/<\/[Ss][Tt][Yy][Ll][Ee]>/)in_style=0;next}
    /^[[:space:]]*```/{if(in_code){print "</code></pre>";in_code=0}else{close_para();close_blocks();close_lists_to(0);line=$0;sub(/^[[:space:]]*```[[:space:]]*/,"",line);lang=line;sub(/[[:space:]]*$/,"",lang);if(lang!="")printf "<pre><code class=\"language-"lang"\">";else printf "<pre><code>";in_code=1}next}
    in_code{gsub(/&/,"\\&amp;",$0);gsub(/</,"\\&lt;",$0);gsub(/>,"\\&gt;",$0);print;next}
    in_html_block{print;if(is_closing_html($0))in_html_block=0;next}
    is_block_html($0){close_para();close_blocks();close_lists_to(0);print;if($0!~/<\/(div|header|footer|nav|section|article|aside|main|form|table|ul|ol|dl|pre|blockquote|h[1-6]|p|hr|address|fieldset|figure)>/)in_html_block=1;next}
    /^[[:space:]]*$/{close_para();close_blocks();if(in_bq){print"</blockquote>";in_bq=0};next}
    /^#{1,6}[[:space:]]/{close_para();close_blocks();close_lists_to(0);n=0;while(substr($0,1,1)=="#"){n++;$0=substr($0,2)};sub(/^[[:space:]]*/,"",$0);id=generate_id($0);printf "<h%d id=\"%s\">%s</h%d>\n",n,id,process_inline($0),n;next}
    /^[[:space:]]*([-*_][[:space:]]*){3,}$/{close_para();close_blocks();close_lists_to(0);print"<hr>";next}
    /^[[:space:]]*>/{close_para();if(!in_bq){close_blocks();close_lists_to(0);print"<blockquote>";in_bq=1};line=$0;sub(/^[[:space:]]*>[[:space:]]*/,"",line);print"<p>"process_inline(line)"</p>";next}
    /^[[:space:]]*[-*+][[:space:]]+/{match($0,/^[ \t]*/);indent=RLENGTH;close_para();close_blocks();handle_list("ul",indent);sub(/^[[:space:]]*[-*+][[:space:]]*/,"",$0);print"<li>"process_inline($0)"</li>";next}
    /^[[:space:]]*[0-9]+\.[[:space:]]+/{match($0,/^[ \t]*/);indent=RLENGTH;close_para();close_blocks();handle_list("ol",indent);sub(/^[[:space:]]*[0-9]+\.[[:space:]]*/,"",$0);print"<li>"process_inline($0)"</li>";next}
    /^[[:space:]]*\|/{close_para();line=$0;sub(/^[[:space:]]*\|/,"",line);sub(/\|\s*$/,"",line);n=split(line,cols,/\|/);sep="^[[:space:]]*:?-+:?[[:space:]]*$";is_sep=1;for(i=1;i<=n;i++)if(cols[i]!~sep)is_sep=0;if(!in_table){close_blocks();close_lists_to(0);print"<table><thead>";in_table=1;in_thead=1;delete align}if(is_sep){for(i=1;i<=n;i++){cell=cols[i];gsub(/^[[:space:]]+|[[:space:]]+$/,"",cell);if(cell~/^:[^-]*-+[^-]*:$/)align[i]="center";else if(cell~/^:[^-]*-+$/)align[i]="left";else if(cell~/^-+[^-]*:$/)align[i]="right";else align[i]=""}print"</thead>\n<tbody>";in_thead=0;in_tbody=1;next}printf"<tr>";for(i=1;i<=n;i++){cell=process_inline(cols[i]);tag=in_thead?"th":"td";if(align[i]!="")printf"<%s align=\"%s\">%s</%s>",tag,align[i],cell,tag;else printf"<%s>%s</%s>",tag,cell,tag}print"</tr>";next}
    {if(in_bq&&$0!~/^[[:space:]]*>/){print"</blockquote>";in_bq=0};close_lists_to(0);close_blocks();if($0~/^[[:space:]]*</){close_para();print}else if($0~/[^[:space:]]/){if(!in_para){printf"<p>%s",process_inline($0);in_para=1}else{printf" %s",process_inline($0)}}}
    END{close_blocks();close_lists_to(0);close_para();if(in_bq)print"</blockquote>";if(in_code)print"</code></pre>";printf"\n"}
EOF
	)
	$AWK_CMD "$script"
}

# Processes templates, conditionals, and includes
run_template_processor() {
	_title="$1"
	_page="$2"
	_ext="$3"

	shift 3

	script=$(
		cat <<'EOF'
      BEGIN{content_c=0;cond_depth=0;print_ok[0]=1;branch_taken[0]=0;block="";inc_filename="";markdown_flag=0;state="NORMAL"}
      function ac(line,i,out,pos,rest){
        out=""; rest=line
        while((pos=index(rest,"{{content}}"))>0){
          out=out substr(rest,1,pos-1)
          for(i=1;i<=content_c;i++) out=out content[i] "\n"
          rest=substr(rest,pos+length("{{content}}"))
        }
        rest=out rest; out=""
        while(match(rest,/\{\{[[:space:]]*content[[:space:]]*\}\}/)){
          out=out substr(rest,1,RSTART-1)
          for(i=1;i<=content_c;i++) out=out content[i] "\n"
          rest=substr(rest,RSTART+RLENGTH)
        }
        print out rest
      }
      function trim(s){gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s}
      function cn(t){gsub(/\n|[[:space:]]+/," ",t); return trim(t)}
      function pc(tag,tn,type,target,current_val,is_met,can_take){
        tn=cn(tag)
        if(tn~/^\{\{[[:space:]]*IF_(EXT|PAGE):/){
          cond_depth++; type=(tn~/IF_EXT:/)?"EXT":"PAGE"
          sub(/^\{\{[[:space:]]*IF_(EXT|PAGE):/,"",tn); sub(/\}\}.*/,"",tn)
          target=trim(tn); current_val=(type=="EXT")?current_ext:current_page
          is_met=(target==current_val)
          print_ok[cond_depth]=print_ok[cond_depth-1]&&is_met
          branch_taken[cond_depth]=print_ok[cond_depth]?1:0; return 1
        } else if(tn~/^\{\{[[:space:]]*ELIF_(EXT|PAGE):/){
          type=(tn~/ELIF_EXT:/)?"EXT":"PAGE"
          sub(/^\{\{[[:space:]]*ELIF_(EXT|PAGE):/,"",tn); sub(/\}\}.*/,"",tn)
          target=trim(tn); current_val=(type=="EXT")?current_ext:current_page
          can_take=print_ok[cond_depth-1]&&!branch_taken[cond_depth]; is_met=(target==current_val)
          print_ok[cond_depth]=can_take&&is_met; if(print_ok[cond_depth]) branch_taken[cond_depth]=1; return 1
        } else if(tn~/^\{\{[[:space:]]*ELSE_(EXT|PAGE)/){
          can_take=print_ok[cond_depth-1]&&!branch_taken[cond_depth]
          print_ok[cond_depth]=can_take; if(can_take) branch_taken[cond_depth]=1; return 1
        } else if(tn~/^\{\{[[:space:]]*ENDIF_(EXT|PAGE)/){ cond_depth--; return 1 }
        return 0
      }
      function it(s){gsub(/^[[:space:]]+|[[:space:]]+$/,"",s); return s}
      function lt(fp,arr,n,line){n=0; while((getline line<fp)>0) arr[++n]=line; close(fp); return n}
      function rd(arr,n,params,block,i,key,line,rest,p,out){
        for(i=1;i<=n;i++){
          line=arr[i]; for(key in params) gsub("{{"key"}}",params[key],line)
          rest=line; out=""
          while((p=index(rest,"{{content}}"))>0){ out=out substr(rest,1,p-1) block; rest=substr(rest,p+length("{{content}}")) }
          print out rest
        }
      }
      function pt(full,s,ps,key,val,eq,vs,qc,off){
        s=it(full); gsub(/\n/," ",s); sub(/^.*include-block[[:space:]]*:/,"",s); sub(/\}\}.*/,"",s); s=it(s)
        if(match(s,/^[^[:space:]]+/)){ inc_filename=substr(s,RSTART,RLENGTH); ps=it(substr(s,RSTART+RLENGTH)) } else { inc_filename=""; ps="" }
        delete params; markdown_flag=0
        while(ps){
          eq=index(ps,"="); if(eq<=1) break
          key=it(substr(ps,1,eq-1)); qc=substr(ps,eq+1,1)
          if(qc!="\"" && qc!="\047"){
            if(match(substr(ps,eq+1),/[[:space:]]+/)){ val=substr(ps,eq+1,RSTART-1); ps=it(substr(ps,eq+1+RLENGTH)) } else { val=substr(ps,eq+1); ps="" }
          } else {
            vs=eq+2; off=index(substr(ps,vs),qc); if(!off) break; val=substr(ps,vs,off-1); ps=it(substr(ps,vs+off))
          }
          params[key]=val; if(key=="markdown" && (val=="true" || val=="1")) markdown_flag=1
        }
      }
      function pl(line,rest,match_pos,before,directive,norm,f,fname,p,il){
        rest=line
        while(rest!=""){
          match_pos=match(rest,/\{\{[[:space:]]*(IF_|ELIF_|ELSE_|ENDIF_|include-block:|include:)/)
          if(match_pos==0){ if(print_ok[cond_depth]) ac(rest); return }
          before=substr(rest,1,match_pos-1); if(before!"" && print_ok[cond_depth]) ac(before)
          directive=substr(rest,match_pos); if(!match(directive,/\}\}/)){ if(print_ok[cond_depth]) ac(directive); return }
          directive=substr(directive,1,RSTART+RLENGTH-1); norm=directive; gsub(/\n|[[:space:]]+/," ",norm)
          if(pc(norm)){}
          else if(norm~/\{\{[[:space:]]*include:[^}]+\}\}/){
            if(print_ok[cond_depth]){
              f=norm; sub(/^.*include[[:space:]]*:/,"",f); sub(/\}\}.*/,"",f); fname=it(f); p=INC_DIR"/"fname
              if(system("test -f \""p"\"")==0){ while((getline il<p)>0) print il; close(p) } else print "<!-- include file not found: " fname " -->"
            }
          } else if(norm~/\{\{[[:space:]]*include-block:/){
            if(print_ok[cond_depth]){ pt(norm); state="INCLUDE_BLOCK"; block="" } ; return
          } else { if(print_ok[cond_depth]) print directive }
          rest=substr(rest,match_pos+length(directive))
        }
      }
      FILENAME=="-"{ content[++content_c]=$0; next }
      {
        line=$0; gsub(/\{\{title\}\}/, template_title_value, line)
        gsub(/\{\{[[:space:]]*BASE_URL[[:space:]]*\}\}/, BASE_URL, line)
        if(state=="INCLUDE_BLOCK"){
          if(line~/\{\{[[:space:]]*endinclude/){
            p=INC_DIR"/"inc_filename
            if(system("test -f \"" p "\"")==0){
              tn=lt(p,tpl)
              if(markdown_flag){
                cmd="mktemp"; cmd|getline tmpfile; close(cmd)
                print block > tmpfile; close(tmpfile)
                cmd=SCRIPT_PATH " --_md \"" tmpfile "\""
                block_html=""
                while((cmd|getline bl)>0) block_html = block_html (block_html ? "\n" : "") bl
                close(cmd)
                rd(tpl,tn,params,block_html)
                system("rm -f " tmpfile)
              } else rd(tpl,tn,params,block)
            } else print "<!-- include-block file not found: " inc_filename " -->"
            state="NORMAL"
          } else { block = block (block ? "\n" : "") line }
          next
        }
        if(line~/^[[:space:]]*$/){ if(print_ok[cond_depth]) print line; next }
        pl(line)
      }
EOF
	)
	$AWK_CMD -v template_title_value="$_title" \
		-v current_page="$_page" -v current_ext="$_ext" \
		-v INC_DIR="src/includes" -v pid="$$" -v BASE_URL="${FSSG_BASE_URL}" \
		-v SCRIPT_PATH="$SCRIPT_PATH" "$script" "$@"
}

# Hoists styles and scripts to the end of <head> and <body> respectively
process_styles_and_scripts() {
	script=$(
		cat <<'EOF'
    BEGIN { s=0; b=""; sc=0; tc=0 }
    /<style\b[^>]*>/ { s=1; b=$0; next }
    /<\/style>/ && s==1 { S[++sc] = b RS $0; s=0; b=""; next }
    s==1 { b = b RS $0; next }
    /<script\b[^>]*>/ { s=2; b=$0; next }
    /<\/script>/ && s==2 { T[++tc] = b RS $0; s=0; b=""; next }
    s==2 { b = b RS $0; next }
    /<style\b[^>]*>.*<\/style>/ { S[++sc] = $0; next }
    /<script\b[^>]*>.*<\/script>/ { T[++tc] = $0; next }
    /<\/head>/ {
      for(i=1; i<=sc; i++) print S[i];
      print;
      next
    }
    /<\/body>/ {
      for(i=1; i<=tc; i++) print T[i];
      print;
      next
    }
    { print }
EOF
	)
	$AWK_CMD "$script"
}

# Minifies and writes final HTML, preserving <pre> blocks verbatim.
minify_and_write() {
	out_file="$1"
	if [ "$MINIFY" -eq 0 ]; then
		process_styles_and_scripts >"$out_file"
		return 0
	fi

	script=$(
		cat <<'EOF'
    { buf = buf $0 "\n" }
    function is_ws(c){ return c~/[[:space:]]/ }
    function strip_html_comments(s, out, cs, ce){
      out = ""
      while (1) {
        cs = index(s, "<!--")
        if (cs == 0) { out = out s; break }
        out = out substr(s, 1, cs-1)
        s = substr(s, cs+4)
        ce = index(s, "-->")
        if (ce == 0) break
        s = substr(s, ce+3)
      }
      return out
    }
    function strip_css_js_comments(s, is_js, out, i, L, ch, in_s, sc, in_c, is_line, nx){
      out=""; i=1; L=length(s); in_s=0; sc=""; in_c=0; is_line=0
      while(i<=L){
        ch=substr(s,i,1)
        if(in_c){
          if(is_line && ch=="\n"){ in_c=0; out=out ch; i++; continue }
          if(!is_line && ch=="*" && substr(s,i+1,1)=="/"){ in_c=0; i+=2; continue }
          i++; continue
        }
        if(in_s){ out=out ch; if(ch==sc && substr(s,i-1,1)!="\\") in_s=0; i++; continue }
        if(ch=="\"" || ch==sprintf("%c",39)){ in_s=1; sc=ch; out=out ch; i++; continue }
        if(ch=="/" && i<L){ nx=substr(s,i+1,1)
          if(nx=="*"){ in_c=1; is_line=0; i+=2; continue }
          if(is_js && nx=="/"){ in_c=1; is_line=1; i+=2; continue }
        }
        out=out ch; i++
      }
      return out
    }
    function minify_chunk(s, j, slen, ch, res, tag, k, tch, tlen, iq, qch, pend, m, txt, cleaned){
      s = strip_html_comments(s)
      res=""; j=1; slen=length(s)
      while(j<=slen){
        ch=substr(s,j,1)
        if(ch=="<"){
          tag=""; iq=0; qch=""; k=j
          while(k<=slen){
            tch=substr(s,k,1); tag=tag tch
            if(tch=="\"" || tch==sprintf("%c",39)){
              if(!iq){ iq=1; qch=tch } else if(qch==tch) iq=0
            } else if(tch==">" && !iq){ k++; break }
            k++
          }
          cleaned=""; pend=0; tlen=length(tag); iq=0; qch=""
          for(m=1;m<=tlen;m++){
            tch=substr(tag,m,1)
            if(tch=="\"" || tch==sprintf("%c",39)){
              cleaned = cleaned tch
              if(!iq){ iq=1; qch=tch } else if(qch==tch) iq=0
              pend=0
            } else if(!iq && is_ws(tch)) pend=1
            else {
              if(pend){
                if(length(cleaned)>0 && substr(cleaned,length(cleaned),1)!="<") cleaned = cleaned " "
                pend=0
              }
              cleaned = cleaned tch
            }
          }
          gsub(/<[[:space:]]+/, "<", cleaned); gsub(/[[:space:]]+>/, ">", cleaned)
          res = res cleaned; j = k
        } else {
          p = index(substr(s,j), "<")
          if(p==0){ txt=substr(s,j); j=slen+1 } else { txt=substr(s,j,p-1); j += p-1 }
          gsub(/[[:space:]]+/, " ", txt); res = res txt
        }
      }
      gsub(/>[[:space:]]*</, "><", res); return res
    }
    END{
      n=length(buf); pos=1; out=""
      while(pos<=n){
        rest=substr(buf,pos)
        if(match(rest, /<[Pp][Rr][Ee]([[:space:]>]|$)/)){
          pre_start = pos + RSTART - 1
          if(pre_start>pos) out = out minify_chunk(substr(buf,pos,pre_start-pos))
          rest2 = substr(buf, pre_start)
          if(match(rest2, /<\/[Pp][Rr][Ee][^>]*>/)){
            pre_end = pre_start + RSTART + RLENGTH - 1
            out = out substr(buf, pre_start, pre_end - pre_start + 1); pos = pre_end + 1; continue
          } else { out = out substr(buf, pre_start); break }
        }
        if(match(rest, /<[Ss][Tt][Yy][Ll][Ee]([[:space:]>]|$)/)){
          style_start = pos + RSTART - 1
          if(style_start>pos) out = out minify_chunk(substr(buf,pos,style_start-pos))
          rest2 = substr(buf, style_start)
          if(match(rest2, /<\/[Ss][Tt][Yy][Ll][Ee][^>]*>/)){
            style_end = style_start + RSTART + RLENGTH - 1
            style_block = substr(buf, style_start, style_end - style_start + 1)
            style_block = strip_css_js_comments(style_block, 0)
            out = out style_block; pos = style_end + 1; continue
          }
        }
        if(match(rest, /<[Ss][Cc][Rr][Ii][Pp][Tt]([[:space:]>]|$)/)){
          script_start = pos + RSTART - 1
          if(script_start>pos) out = out minify_chunk(substr(buf,pos,script_start-pos))
          rest2 = substr(buf, script_start)
          if(match(rest2, /<\/[Ss][Cc][Rr][Ii][Pp][Tt][^>]*>/)){
            script_end = script_start + RSTART + RLENGTH - 1
            script_block = substr(buf, script_start, script_end - script_start + 1)
            script_block = strip_css_js_comments(script_block, 1)
            out = out script_block; pos = script_end + 1; continue
          }
        }
        out = out minify_chunk(rest); break
      }
      printf "%s", out
    }
EOF
	)
	process_styles_and_scripts | $AWK_CMD "$script" >"$out_file"
}

# Process a single file from src/ into dist/
process_file() {
	src_file="$1"
	rel_path="${src_file#src/}"
	extension="${src_file##*.}"
	out_file="dist/${rel_path%.*}.html"

	mkdir -p "$(dirname "$out_file")" ||
		{
			log_error "Failed to create directory for $out_file"
			return 1
		}

	base_name=$(basename "$src_file" ."$extension")
	pretty_title=$(
		echo "$base_name" | tr '-' ' ' |
			$AWK_CMD '{for(i=1;i<=NF;i++)$i=toupper(substr($i,1,1))tolower(substr($i,2));}1'
	)
	raw_content=$(cat "$src_file")
	override_title=$(
		echo "$raw_content" 2>/dev/null |
			$AWK_CMD '/\{\{title:/ {sub(/.*\{\{.*:/,"");sub(/\}\}.*/,"");print;exit}'
	)
	final_title="${override_title:-$pretty_title}"

	page_id="${rel_path%.*}.html"
	template_file="src/template.html"
	if ! [ -f "$template_file" ]; then
		log_verbose "No src/template.html found, processing without a layout."
		template_file="/dev/null"
	fi

	# PASS 1: Process file for includes & conditionals.
	content_with_includes=$(
		echo "" | run_template_processor "$final_title" "$page_id" "$extension" \
			- "$src_file"
	)

	# PASS 1b: Process any template directives that came from includes
	# This ensures {{IF_PAGE:}} etc. from include templates are processed
	# before markdown parsing
	if echo "$content_with_includes" 2>/dev/null | grep -q '{{[[:space:]]*[A-Za-z_]'; then
		log_verbose "Processing template directives from includes..."
		tmpfile_directives=$(mktemp)
		echo "$content_with_includes" >"$tmpfile_directives"
		content_directives_processed=$(
			echo "" | run_template_processor "$final_title" "$page_id" "$extension" \
				- "$tmpfile_directives"
		)
		rm -f "$tmpfile_directives"
	else
		content_directives_processed="$content_with_includes"
	fi

	# Check if include-block with markdown=true was used. If so, the content is
	# already HTML and we should skip the main markdown parsing pass.
	# We detect this by checking if the original file had the directive and the
	# output now looks like an HTML document.
	is_pre_rendered_html=0
	if echo "$raw_content" 2>/dev/null | grep 'include-block:[^}]*markdown="true"' >/dev/null &&
		echo "$content_directives_processed" 2>/dev/null | grep -i '<!DOCTYPE.*html\|<!doctype.*html\|<html>' >/dev/null; then
		log_verbose "Detected pre-rendered HTML from include-block; skipping main markdown pass."
		is_pre_rendered_html=1
	fi

	# PASS 2: If the original file was Markdown and it wasn't pre-rendered...
	if [ "$extension" = "md" ] && [ "$is_pre_rendered_html" -eq 0 ]; then
		body_html=$(
			echo "$content_directives_processed" |
				sed 's/{{title:[^}]*}}//g' |
				parse_markdown
		)
	else
		# Otherwise, just remove the title tag and pass through.
		body_html=$(
			echo "$content_directives_processed" |
				sed 's/{{title:[^}]*}}//g'
		)
	fi

	# PASS 3: Inject body into main template only if it wasn't pre-rendered.
	# Pre-rendered content already has its full layout from the include-block.
	if [ "$is_pre_rendered_html" -eq 1 ]; then
		processed_content="$body_html"
	else
		tmp_body_file="$(mktemp)"
		printf '%s\n' "$body_html" >"$tmp_body_file"

		processed_content=$(
			cat "$tmp_body_file" | run_template_processor "$final_title" "$page_id" "$extension" \
				- "$template_file"
		)

		rm -f "$tmp_body_file"
	fi

	# FINAL STEP: Minify, hoist styles/scripts, and write to disk.
	AUTO_RELOAD_SCRIPT='<script>
if (location.hostname==="localhost"||location.hostname==="127.0.0.1"){
 (function checkAutoReload(){
   let last;
   async function poll(){
     try{
       const res=await fetch("/.reload",{cache:"no-store"});
       const text=await res.text();
       if(last && last!==text.trim()){
         console.log("[autoreload] change detected => reload");
         location.reload();
       }
       last=text.trim();
     }catch(e){
       console.warn("[autoreload] error",e);
     }
     setTimeout(poll,2000);
   }
   poll();
 })();
}
</script>'

	if [ "$WATCH" -eq 1 ] || [ "$SERVE" -eq 1 ]; then
		# inject autoreload script before </body>
		processed_content=$(printf '%s\n' "$processed_content" |
			$AWK_CMD -v script="$AUTO_RELOAD_SCRIPT" '
       /<\/body>/ { print script; print; next }
       { print }
     ')
	fi

	echo "$processed_content" | minify_and_write "$out_file"
	log_verbose "Finished: $src_file -> $out_file"
	return 0
}

# Build the full site
build_site() {
	start_time=$(date +%s)
	log_info "Starting build..."

	rm -rf dist
	mkdir -p dist/static || fatal "Could not create dist/static directory."

	if [ -d src/static ]; then
		log_verbose "Copying static assets..."
		if ! cp -R src/static/. dist/static/ 2>/dev/null; then
			log_warn "Copying static assets failed. Some files might be missing."
		fi
	fi

	file_list=$(mktemp)
	find src -type f \( -name '*.md' -o -name '*.html' \) \
		! -path 'src/includes/*' ! -path 'src/static/*' \
		! -name 'template.html' >"$file_list"

	file_count=$(wc -l <"$file_list" | awk '{print $1}')
	log_info "Found $file_count files to process..."

	BUILD_FAILED=0
	running=0
	processed_count=0
	pids=""

	while IFS= read -r f; do
		(
			log_verbose "Processing: $f"
			if ! process_file "$f"; then
				log_error "Failed to process: $f"
				exit 1
			fi
		) </dev/null &

		pids="$pids $!"
		running=$((running + 1))
		processed_count=$((processed_count + 1))

		if [ "$running" -ge "$MAX_JOBS" ]; then
			# Wait for the first PID in the list to free up a slot
			wait "$(echo "$pids" | cut -d' ' -f2)"
			# Check its exit code
			rc=$?
			if [ "$rc" -ne 0 ]; then BUILD_FAILED=1; fi
			# Remove it from the list
			pids=$(echo "$pids" | cut -d' ' -f3-)
			running=$((running - 1))
		fi
	done <"$file_list"
	rm -f "$file_list"

	# Wait for all remaining background jobs to finish
	if ! wait_for_pids; then
		BUILD_FAILED=1
	fi

	end_time=$(date +%s)
	duration=$((end_time - start_time))

	if [ "$BUILD_FAILED" -eq 0 ]; then
		# Only create the .reload file if watching or serving
		if [ "$WATCH" -eq 1 ] || [ "$SERVE" -eq 1 ]; then
			date +%s >dist/.reload
		fi
		log_info "Build successful! ($processed_count files in ${duration}s)"
		return 0
	else
		log_error "Build finished with errors. Please check logs above."
		return 1
	fi
}

# Starts a web server
start_server() {
	SERVER_CMD=""

	# Allow overriding the exact server command via env var
	if [ -n "${FSSG_SERVER_CMD:-}" ]; then
		SERVER_CMD="$FSSG_SERVER_CMD"
		log_verbose "Using custom server command: $SERVER_CMD"
	fi

	# If no custom command, prefer a local ./mongoose binary
	if [ -z "$SERVER_CMD" ] && [ -d "./mongoose" ]; then
		log_verbose "Found './mongoose' directory, checking for executables..."
		uname_s=$(uname -s 2>/dev/null || echo "")
		case "$uname_s" in
		Darwin*) CAND="./mongoose/mongoose_macos" ;;
		Linux*) CAND="./mongoose/mongoose_linux" ;;
		CYGWIN* | MINGW* | MSYS*) CAND="./mongoose/mongoose_windows.exe" ;;
		*) CAND="./mongoose/mongoose_linux" ;;
		esac

		if [ -x "$CAND" ]; then
			log_verbose "Using platform-specific local mongoose: $CAND"
			SERVER_CMD="$CAND -d dist/ -v 0"
		else
			# Fallback: find any executable file in the directory
			for f in ./mongoose/*; do
				if [ -x "$f" ]; then
					log_verbose "Using fallback local mongoose: $f"
					SERVER_CMD="$f -d dist/ -v 0"
					break
				fi
			done
		fi
	fi

	# If still no server found, check for system-wide commands
	if [ -z "$SERVER_CMD" ]; then
		if command -v mongoose >/dev/null 2>&1; then
			log_verbose "Found 'mongoose' in PATH, using it to serve."
			SERVER_CMD="mongoose -d dist/ -v 0"
		elif command -v python3 >/dev/null 2>&1; then
			log_verbose "Found 'python3', using its http.server module."
			SERVER_CMD="cd dist && python3 -m http.server $FSSG_SERVER_PORT"
		elif command -v python >/dev/null 2>&1; then
			log_verbose "Found 'python', using its SimpleHTTPServer module."
			SERVER_CMD="cd dist && python -m SimpleHTTPServer $FSSG_SERVER_PORT"
		else
			fatal "No server found. Place mongoose in ./mongoose/, or install mongoose or python3/python system-wide."
		fi
	fi

	log_info "Starting server..."
	# Use sh -c to handle complex commands like 'cd ... && ...' properly
	sh -c "$SERVER_CMD" >/dev/null 2>&1 &
	SERVER_PID=$!

	# Wait briefly for the server to bind to the port and check if it's running
	sleep 0.1
	if ! kill -0 "$SERVER_PID" 2>/dev/null; then
		log_error "Server command failed to start."
		log_error "Command was: $SERVER_CMD"
		fatal "Failed to start development server."
	fi

	log_info "Server started at http://localhost:$FSSG_SERVER_PORT (PID: $SERVER_PID)"
	log_info "Press Ctrl+C to stop."
}

# Opens the default web browser
open_browser() {
	url="http://localhost:${FSSG_SERVER_PORT}"
	log_info "Opening browser at $url"
	case "$(uname -s)" in
	Darwin*) open "$url" >/dev/null 2>&1 & ;;
	Linux*) xdg-open "$url" >/dev/null 2>&1 & ;;
	CYGWIN* | MINGW* | MSYS*) start "$url" >/dev/null 2>&1 & ;;
	*) log_info "Please open the URL above in your browser manually." ;;
	esac
}

# Rebuild files on change
watch_mode() {
	log_info "Initial build for watch mode..."
	if ! build_site; then
		log_warn "Initial build failed. Please fix errors before watching."
	fi

	if [ "${SERVE:-0}" -eq 1 ]; then
		start_server
		[ "${OPEN_BROWSER:-0}" = "1" ] && open_browser
	fi

	log_info "Watching src/ for changes (Press Ctrl+C to stop)..."
	snapshot_checksum() { find src -type f -exec cksum {} \; 2>/dev/null | sort | cksum; }
	prev_sum=$(snapshot_checksum)

	while :; do
		sleep 0.5
		cur_sum=$(snapshot_checksum)
		if [ "$prev_sum" != "$cur_sum" ]; then
			log_info "Change detected, rebuilding..."
			if ! build_site; then
				log_error "Build failed after change. Watch will continue."
			fi
			prev_sum=$cur_sum
		fi
	done
}

# Show help message
display_help() {
	cat <<EOF
fssg - Fast, Simple Static Site Generator (v$VERSION).
-----------------------------------------------------

A POSIX-compliant static site generator using standard shell tools.

Usage:
  $(basename "$0") [options]

Options:
  -h, --help            Display the help message (this text).
  -V, --version         Print the fssg version and exit.
  -q, --quiet           Suppress informational and debug output. Errors are still shown.
  -v, --verbose         Enable verbose debug logging to aid troubleshooting.
  -n, --nocolor         Disable ANSI color sequences in messages.
  -m, --minify          Disables HTML minification. This flag is useful for debugging.

Build & Development:
  -w, --watch           Watch the src/ tree and rebuild automatically on changes.
  -s, --serve           Start a local web server that serves dist/ to localhost:8000 (default).
  -o, --open            Open the default web browser after starting the server. This flag
                        requires -s/--serve to be meaningful.
  -j, --jobs <num>      Number of parallel build jobs (default: 100). Controls how many page
                        conversions run in background concurrently. Accepts a positive number.

Environment Variables:
  FSSG_BASE_URL         Base URL for the website (default: none).
  FSSG_SERVER_CMD       Override the server command used by --serve. Example:
                        FSSG_SERVER_CMD="(cd dist && python3 -m http.server 9000)"
  FSSG_SERVER_PORT      Port used by the internal server (default: 8000).
  FSSG_AWK              Custom command for the awk executable (default: awk).
  FSSG_AWK_OPTS         Custom options for the awk executable (default: none).
EOF
}

# Main script entrypoint
main() {
	# Set up traps for cleanup on exit
	trap 'cleanup' EXIT
	trap 'exit 130' INT TERM HUP

	# Handle internal markdown parsing call
	if [ "${1:-}" = "--_md" ]; then
		if [ -n "$2" ] && [ -f "$2" ]; then
			parse_markdown <"$2"
		else
			parse_markdown
		fi
		exit 0
	fi

	# Parse command line arguments
	while [ $# -gt 0 ]; do
		case "$1" in
		-h | --help)
			display_help
			exit 0
			;;
		-V | --version)
			echo "fssg version $VERSION"
			exit 0
			;;
		-q | --quiet)
			QUIET=1
			VERBOSE=0
			shift
			;;
		-v | --verbose)
			VERBOSE=1
			QUIET=0
			shift
			;;
		-n | --nocolor)
			NO_COLOR=1
			shift
			;;
		-w | --watch)
			WATCH=1
			shift
			;;
		-s | --serve)
			SERVE=1
			shift
			;;
		-o | --open)
			OPEN_BROWSER=1
			shift
			;;
		-m | --minify)
			MINIFY=0
			shift
			;;
		-j | --jobs)
			shift
			case $1 in
			*[!0-9]* | '') fatal "-j/--jobs requires a numeric argument." ;;
			*) MAX_JOBS=$1 ;;
			esac
			shift
			;;
		--)
			shift
			break
			;;
		-*) fatal "Unknown option: $1. Use --help for usage info." ;;
		*) break ;;
		esac
	done

	# Set color variables
	if [ "$NO_COLOR" -eq 1 ] || ! [ -t 1 ]; then
		GREEN="" RED="" YELLOW="" BLUE="" NC=""
	else
		GREEN=$(printf '\033[0;32m')
		RED=$(printf '\033[0;31m')
		YELLOW=$(printf '\033[0;33m')
		BLUE=$(printf '\033[0;34m')
		NC=$(printf '\033[0m')
	fi

	if ! [ -d "src" ]; then
		fatal "Source directory 'src' not found. Please create it and add content."
	fi

	if [ "$WATCH" -eq 1 ]; then
		watch_mode
	else
		build_site
		build_status=$?
		if [ "$SERVE" -eq 1 ]; then
			if [ $build_status -ne 0 ]; then
				log_warn "Build failed. Server will not be started."
			else
				start_server
				[ "$OPEN_BROWSER" -eq 1 ] && open_browser
				wait "$SERVER_PID"
			fi
		fi
		exit $build_status
	fi
}

main "$@"
# vim: set tabstop=2 shiftwidth=2 expandtab: