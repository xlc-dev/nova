#!/bin/sh

# -----------------------------------------------------------------------------
# fssg - Fast, Simple Static Site Generator
#
# A minimal, fast static site generator built with POSIX shell scripting.
# It transforms Markdown and HTML files into a complete website by applying
# templates, processing includes, conditionals, pagination, and events.
# Static assets are copied automatically, producing a ready-to-deploy `dist`
# directory.
#
# Usage: ./fssg [options]
#
# Options:
#   -h, --help     Display this help message
#   -q, --quiet    Suppress all output except errors
#   -v, --verbose  Show detailed build information
#   -V, --version  Show version information of this version of fssg
#   -n, --nocolor  Disable colored output
#   -w, --watch    Watch for changes and rebuild automatically
#   -o, --open     Open the browser automatically (requires -s)
#   -s, --serve    Start a local Mongoose server for serving the dist dir
#   -j, --jobs     Number of background jobs to run (default: 4)
#
# License: MIT License (see below)
#
# Copyright (c) xlc-dev 2025
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -----------------------------------------------------------------------------

# global variables
VERSION="1.1"
QUIET=0
VERBOSE=0
MAX_JOBS=4
WATCH=0
SERVE=0
OPEN_BROWSER_FLAG=0
NO_COLOR=0
SERVER_PID=""

# Script self-reference for recursive calls (e.g., markdown processing)
SCRIPT_PATH="$0"

# AWK script for Markdown to HTML conversion
read -r -d '' MARKDOWN_AWK <<'EOF'
BEGIN {
    list_depth = 0; in_code = 0; in_table = 0; in_thead = 0
    in_tbody = 0; in_bq = 0; in_para = 0
}
function close_para() { if (in_para) { print "</p>"; in_para = 0 } }
function open_list(type, indent) {
    list_depth++; list_type[list_depth]=type; list_indent[list_depth]=indent
    print "<" type ">"
}
function close_list() {
    print "</" list_type[list_depth] ">"; delete list_type[list_depth]
    delete list_indent[list_depth]; list_depth--
}
function close_lists_to(indent) {
    while (list_depth > 0 && list_indent[list_depth] >= indent) close_list()
}
function handle_list(type, indent) {
    while (list_depth > 0 && (list_indent[list_depth] > indent ||
           (list_indent[list_depth] == indent && list_type[list_depth] != type))) {
        close_list()
    }
    if (list_depth == 0 || list_indent[list_depth] < indent) open_list(type, indent)
}
function close_blocks() {
    if (in_code) { print "</code></pre>"; in_code = 0 }
    if (in_table) {
        if (in_tbody) print "</tbody>"; else if (in_thead) print "</thead>"
        print "</table>"; in_table = in_thead = in_tbody = 0
    }
}
function process_inline(text, pre, post, m, a, b, c, rep) {
    while (match(text, /!\[[^]]*\]\([^)]+\)/)) {
        pre=substr(text,1,RSTART-1); m=substr(text,RSTART,RLENGTH); post=substr(text,RSTART+RLENGTH)
        a=index(m,"]("); b=substr(m,3,a-3); c=substr(m,a+2,length(m)-a-2)
        rep=sprintf("<img src=\"%s\" alt=\"%s\">", c, b); text=pre rep post
    }
    while (match(text, /\[[^]]+\]\([^)]+\)/)) {
        pre=substr(text,1,RSTART-1); m=substr(text,RSTART,RLENGTH); post=substr(text,RSTART+RLENGTH)
        a=index(m,"]("); b=substr(m,2,a-2); c=substr(m,a+2,length(m)-a-2)
        rep=sprintf("<a href=\"%s\">%s</a>", c, b); text=pre rep post
    }
    while (match(text, /(\*\*\*|___)[^*_]+(\*\*\*|___)/)) {
        pre=substr(text,1,RSTART-1); m=substr(text,RSTART,RLENGTH); post=substr(text,RSTART+RLENGTH)
        b=substr(m,4,length(m)-6); rep="<strong><em>" b "</em></strong>"; text=pre rep post
    }
    while (match(text, /(\*\*|__)[^*_]+(\*\*|__)/)) {
        pre=substr(text,1,RSTART-1); m=substr(text,RSTART,RLENGTH); post=substr(text,RSTART+RLENGTH)
        b=substr(m,3,length(m)-4); rep="<strong>" b "</strong>"; text=pre rep post
    }
    while (match(text, /(\*|_)[^*_]+(\*|_)/)) {
        pre=substr(text,1,RSTART-1); m=substr(text,RSTART,RLENGTH); post=substr(text,RSTART+RLENGTH)
        b=substr(m,2,length(m)-2); rep="<em>" b "</em>"; text=pre rep post
    }
    while (match(text, /~~[^~]+~~/)) {
        pre=substr(text,1,RSTART-1); m=substr(text,RSTART,RLENGTH); post=substr(text,RSTART+RLENGTH)
        b=substr(m,3,length(m)-4); rep="<del>" b "</del>"; text=pre rep post
    }
    while (match(text, /`[^`]+`/)) {
        pre=substr(text,1,RSTART-1); m=substr(text,RSTART,RLENGTH); post=substr(text,RSTART+RLENGTH)
        b=substr(m,2,length(m)-2); rep="<code>" b "</code>"; text=pre rep post
    }
    return text
}
/^[[:space:]]*```/ {
    if (in_code) { print "</code></pre>"; in_code = 0
    } else {
        close_para(); close_blocks(); close_lists_to(0); line = $0
        sub(/^[[:space:]]*```[[:space:]]*/, "", line); lang = line; sub(/[[:space:]]*$/, "", lang)
        if (lang != "") print "<pre><code class=\"language-" lang "\">"; else print "<pre><code>"
        in_code = 1
    }
    next
}
in_code { gsub(/&/, "&amp;"); gsub(/</, "&lt;"); gsub(/>/, "&gt;"); print; next }
/^[[:space:]]*<\/?([a-zA-Z])/ { close_para(); close_lists_to(0); print; next }
/^[[:space:]]*$/ {
    close_para(); close_blocks()
    if (in_bq) { print "</blockquote>"; in_bq = 0 }
    next
}
/^#{1,6}[[:space:]]/ {
    close_para(); close_blocks(); close_lists_to(0); n = 0
    while (substr($0,1,1) == "#") { n++; $0 = substr($0,2) }
    sub(/^[[:space:]]*/, "", $0); printf "<h%d>%s</h%d>\n", n, process_inline($0), n; next
}
/^[[:space:]]*([-*_][[:space:]]*){3,}$/ { close_para(); close_blocks(); close_lists_to(0); print "<hr>"; next }
/^[[:space:]]*>/ {
    close_para()
    if (!in_bq) { close_blocks(); close_lists_to(0); print "<blockquote>"; in_bq = 1 }
    line = $0; sub(/^[[:space:]]*>[[:space:]]*/, "", line); print "<p>" process_inline(line) "</p>"; next
}
/^[[:space:]]*[-*+][[:space:]]+/ {
    match($0,/^[ \t]*/); indent = RLENGTH; close_para(); close_blocks()
    handle_list("ul", indent); sub(/^[[:space:]]*[-*+][[:space:]]*/, "", $0)
    print "<li>" process_inline($0) "</li>"; next
}
/^[[:space:]]*[0-9]+\.[[:space:]]+/ {
    match($0,/^[ \t]*/); indent = RLENGTH; close_para(); close_blocks()
    handle_list("ol", indent); sub(/^[[:space:]]*[0-9]+\.[[:space:]]*/, "", $0)
    print "<li>" process_inline($0) "</li>"; next
}
/^[[:space:]]*\|/ {
    close_para(); line = $0; sub(/^[[:space:]]*\|/,"",line); sub(/\|\s*$/,"",line)
    n = split(line,cols,/\|/); sep = "^[[:space:]]*:?-+:?[[:space:]]*$"; is_sep = 1
    for (i=1; i<=n; i++) if (cols[i]!~sep) is_sep=0
    if (!in_table) { close_blocks(); close_lists_to(0); print "<table>"; in_table=1; in_thead=1; delete align }
    if (is_sep) {
        for (i=1; i<=n; i++) {
            cell = cols[i]; gsub(/^[[:space:]]+|[[:space:]]+$/,"",cell)
            if (cell~/^:[^-]*-+[^-]*:$/) align[i]="center"
            else if (cell~/^:[^-]*-+$/) align[i]="left"
            else if (cell~/^-+[^-]*:$/) align[i]="right"
            else align[i]=""
        }
        print "</thead>\n<tbody>"; in_thead=0; in_tbody=1; next
    }
    printf "<tr>"
    for (i=1; i<=n; i++) {
        cell = process_inline(cols[i]); tag = in_thead ? "th" : "td"
        if (align[i]!="") printf "<%s align=\"%s\">%s</%s>",tag,align[i],cell,tag
        else printf "<%s>%s</%s>",tag,cell,tag
    }
    print "</tr>"; next
}
{
    if (in_bq && $0 !~ /^[[:space:]]*>/) { print "</blockquote>"; in_bq = 0 }
    close_blocks()
    if (!in_para) { printf "<p>%s", process_inline($0); in_para = 1
    } else { printf " %s", process_inline($0) }
}
END { close_blocks(); close_lists_to(0); close_para(); if (in_bq) print "</blockquote>" }
EOF

# AWK script for applying template
read -r -d '' TEMPLATE_AWK <<'EOF'
BEGIN { c=0 }
FILENAME=="-" { content[++c] = $0; next }
{
    line = $0
    gsub(/\{\{[[:space:]]*title[[:space:]]*\}\}/, template_title_value, line)
    while (match(line, /\{\{[[:space:]]*content[[:space:]]*\}\}/)) {
        printf "%s", substr(line,1,RSTART-1)
        for (i=1;i<=c;i++) print content[i]
        line = substr(line, RSTART+RLENGTH)
    }
    print line
}
EOF

# AWK script for processing conditionals (IF_PAGE, IF_EXT, etc.)
read -r -d '' CONDITIONALS_AWK <<'EOF'
function trim(s) { gsub(/^[[:space:]]+|[[:space:]]+$/, "", s); return s }
function normalize(tag) { gsub(/\n|[[:space:]]+/, " ", tag); return trim(tag) }
BEGIN { depth=0; print_ok[0]=1; branch_taken[0]=0; state=0; tag_accumulator="" }
{
    line = $0
    if (state==0 && match(line, /\{\{[[:space:]]*(IF_|ELIF_|ELSE_|ENDIF_)/)) {
        state=1; tag_accumulator=""
    }
    if (state==1) {
        tag_accumulator = tag_accumulator (tag_accumulator? "\n":"") line
        if (tag_accumulator ~ /\}\}/) {
            tag_norm = normalize(tag_accumulator)
            if (tag_norm ~ /^\{\{[[:space:]]*IF_(EXT|PAGE):/) {
                depth++;
                type = (tag_norm ~ /IF_EXT:/) ? "EXT" : "PAGE"
                sub(/^\{\{[[:space:]]*IF_(EXT|PAGE):/,"",tag_norm); sub(/\}\}.*/,"",tag_norm)
                target = trim(tag_norm)
                current_val = (type == "EXT") ? current_ext : current_page
                is_met = (target == current_val)
                print_ok[depth] = print_ok[depth-1] && is_met
                branch_taken[depth] = print_ok[depth] ? 1 : 0
            }
            else if (tag_norm ~ /^\{\{[[:space:]]*ELIF_(EXT|PAGE):/) {
                type = (tag_norm ~ /ELIF_EXT:/) ? "EXT" : "PAGE"
                sub(/^\{\{[[:space:]]*ELIF_(EXT|PAGE):/,"",tag_norm); sub(/\}\}.*/,"",tag_norm)
                target = trim(tag_norm)
                current_val = (type == "EXT") ? current_ext : current_page
                can_take = print_ok[depth-1] && !branch_taken[depth]
                is_met = (target == current_val)
                print_ok[depth] = can_take && is_met
                if (print_ok[depth]) branch_taken[depth]=1
            }
            else if (tag_norm ~ /^\{\{[[:space:]]*ELSE_(EXT|PAGE)/) {
                can_take = print_ok[depth-1] && !branch_taken[depth]
                print_ok[depth] = can_take
                if (can_take) branch_taken[depth]=1
            }
            else if (tag_norm ~ /^\{\{[[:space:]]*ENDIF_(EXT|PAGE)/) {
                depth--
            }
            else { print tag_accumulator }
            state=0; next
        }
        next
    }
    if (print_ok[depth]) print line
}
EOF

# AWK script for processing includes
read -r -d '' INCLUDES_AWK <<'EOF'
function trim(s){ gsub(/^[[:space:]]+|[[:space:]]+$/, "", s); return s }
function load_template(fp, arr, n, line){ n=0; while((getline line<fp)>0) arr[++n]=line; close(fp); return n }
function render(arr, n, params, block, i, key, line, out, rest, p) {
    for(i=1; i<=n; i++) {
        line=arr[i]
        for(key in params) gsub("{{"key"}}", params[key], line)
        rest=line; out=""
        while((p=index(rest,"{{content}}"))>0) {
            out = out substr(rest,1,p-1) block
            rest = substr(rest,p+length("{{content}}"))
        }
        print out rest
    }
}
function parse_tag(full, s, ps, key, val, eq, vs, qc, off) {
    s=trim(full); gsub(/\n/," ",s)
    sub(/^.*include-block[[:space:]]*:/,"",s); sub(/\}\}.*/,"",s); s=trim(s)
    if (match(s,/^[^[:space:]]+/)) {
        filename=substr(s,RSTART,RLENGTH); ps=trim(substr(s,RSTART+RLENGTH))
    } else { filename=""; ps="" }
    delete params; markdown_flag=0
    while(ps) {
        eq=index(ps,"="); if(eq<=1) break
        key=trim(substr(ps,1,eq-1)); qc=substr(ps,eq+1,1)
        if(qc!="\""&&qc!="\047"){
            if(match(substr(ps,eq+1),/[[:space:]]+/)){
                val=substr(ps,eq+1,RSTART-1); ps=trim(substr(ps,eq+1+RLENGTH))
            } else { val=substr(ps,eq+1); ps="" }
        } else {
            vs=eq+2; off=index(substr(ps,vs),qc); if(!off) break
            val=substr(ps,vs,off-1); ps=trim(substr(ps,vs+off))
        }
        params[key]=val
        if (key=="markdown" && (val=="true" || val=="1")) markdown_flag=1
    }
}
BEGIN { state=0; tag_acc=""; block=""; filename=""; markdown_flag=0 }
{
    line=$0
    if (state==0 && match(line, /\{\{[[:space:]]*(include(-block)?)/)) {
        state=1; tag_acc=""; block=""
    }
    if (state==1) {
        tag_acc = tag_acc (tag_acc? "\n":"") line
        if(tag_acc ~ /\}\}/) {
            norm=tag_acc; gsub(/\n|[[:space:]]+/," ",norm)
            if (norm ~ /\{\{[[:space:]]*include:[^}]+\}\}/) {
                f=norm; sub(/^.*include[[:space:]]*:/,"",f); sub(/\}\}.*/,"",f)
                fname=trim(f); p=INC_DIR"/"fname
                if(system("test -f \""p"\"")==0) { while((getline il<p)>0) print il; close(p) }
                else print tag_acc
                state=0
            } else if (norm ~ /\{\{[[:space:]]*include-block:/) {
                parse_tag(norm); state=2
            } else { print tag_acc; state=0 }
        }
        next
    }
    if (state==2) {
        if (line ~ /\{\{[[:space:]]*endinclude/) {
            p=INC_DIR"/"filename
            if (system("test -f \""p"\"")==0) {
                tn=load_template(p,tpl)
                if (markdown_flag) {
                    tf = ".tmp_block_" PROCINFO["pid"]
                    print block > tf; close(tf)
                    of = ".tmp_md_" PROCINFO["pid"]
                    system("\"" SCRIPT_PATH "\" --_md < \"" tf "\" > \"" of "\"")
                    block_html=""; while((getline bl < of)>0) block_html=block_html (block_html?"\n":"") bl
                    close(of); system("rm -f \"" of "\" \"" tf "\"")
                    render(tpl,tn,params,block_html)
                } else { render(tpl,tn,params,block) }
            } else print tag_acc block line
            state=0; tag_acc=""; block=""
        } else { block = block (block? "\n":"") line }
        next
    }
    if (state==0) print line
}
EOF

# AWK script for deduplicating and hoisting styles/scripts
read -r -d '' STYLES_SCRIPTS_AWK <<'EOF'
BEGIN { state=0; buffer="" }
/<style[^>]*>.*<\/style>/i { styles[$0]=1; next }
/<script[^>]*>.*<\/script>/i { scripts[$0]=1; next }
/<style[^>]*>/i { state=1; buffer=$0; next }
/<\/style>/i && state==1 { buffer=buffer"\n"$0; styles[buffer]=1; state=0; buffer=""; next }
state==1 { buffer=buffer"\n"$0; next }
/<script[^>]*>/i { state=2; buffer=$0; next }
/<\/script>/i && state==2 { buffer=buffer"\n"$0; scripts[buffer]=1; state=0; buffer=""; next }
state==2 { buffer=buffer"\n"$0; next }
{ content[NR]=$0 }
END {
    for (i=1; i<=NR; i++) {
        if (i in content) {
            line = content[i]
            if (line ~ /<\/head>/i) { for (s in styles) print s }
            print line
            if (line ~ /<\/body>/i) { for (s in scripts) print s }
        }
    }
}
EOF

# Logger functions
log_info()    { [ "$QUIET" -eq 0 ] && printf '%s[INFO]%s %s\n'  "$GREEN" "$NC" "$1"; }
log_verbose() { [ "$VERBOSE" -eq 1 ] && printf '%s[DEBUG]%s %s\n' "$BLUE" "$NC" "$1"; }
log_warn()    { [ "$QUIET" -eq 0 ] && printf '%s[WARN]%s %s\n'  "$YELLOW" "$NC" "$1" >&2; }
log_error()   { printf '%s[ERROR]%s %s\n' "$RED" "$NC" "$1" >&2; }
fatal()       { log_error "$1"; exit 1; }

# Wrapper for the markdown AWK script
parse_markdown() {
    awk "$MARKDOWN_AWK"
}

# Injects title and content into a template file
apply_template() {
    template_path="$1"
    title_val="$2"
    awk -v template_title_value="$title_val" "$TEMPLATE_AWK" - "$template_path"
}

# Processes IF/ELIF/ELSE/ENDIF blocks based on page name or extension
process_conditionals() {
    page_id="$1"; ext="$2"
    awk -v current_page="$page_id" -v current_ext="$ext" "$CONDITIONALS_AWK"
}

# Handles {{ include }} and {{ include-block }} directives
process_includes() {
    # The SELF var is used by the awk script to call back into this script
    # to process markdown blocks.
    awk -v INC_DIR="src/includes" -v SCRIPT_PATH="$SCRIPT_PATH" "$INCLUDES_AWK"
}

# Deduplicates <style> and <script> blocks and moves them
process_styles_and_scripts() {
    awk "$STYLES_SCRIPTS_AWK"
}

# Resolve "." and ".." in paths to create a canonical path
normalize_path() {
    path="$1"
    is_absolute=0
    prefix=""
    case "$path" in /*) is_absolute=1; path="${path#?}"; prefix="/";; esac
    old_ifs="$IFS"; IFS='/'; set -- $path; IFS="$old_ifs"
    out=""
    for comp in "$@"; do
        if [ "$comp" = "." ] || [ -z "$comp" ]; then continue; fi
        if [ "$comp" = ".." ]; then
            if [ -n "$out" ]; then out="${out%/*}";
            elif [ "$is_absolute" -eq 0 ]; then out="${out:+$out/}.."; fi
        else
            out="${out:+$out/}$comp"
        fi
    done
    if [ "$is_absolute" -eq 1 ]; then printf '/%s\n' "${out#?}";
    else printf '%s\n' "${out:-.}"; fi
}

# Finds dated files, extracts metadata, and sorts them newest-first
collect_posts() {
    find src -type f ! -path 'src/includes/*' ! -path 'src/static/*' \
        \( -name '*.md' -o -name '*.html' \) |
    while IFS= read -r file; do
        filename=${file##*/}
        # Extract date and slug from various filename formats
        case "$filename" in
          ????-??-??-*)
            date=${filename%%-*}; rest=${filename#*-}; slug=${rest%.*}
            sort_key=$(echo "$date" | tr -d '-') ;;
          *) continue ;; # Simplified to one common format for brevity
        esac
        out_path="dist/${file#src/}"
        out_path="${out_path%.*}.html"
        # Find first image in the file
        img=$(sed -n 's/.*<img[^>]*src=["'\'']\([^"'\'']*\).*/\1/p' "$file" | head -1)
        image_path=""
        if [ -n "$img" ]; then
            case "$img" in
                http://*|https://*|//*) image_path="$img";;
                /*) image_path="${img#/}";;
                *)
                    # Correctly resolve relative paths
                    normalized=$(normalize_path "$(dirname "$file")/$img")
                    image_path=${normalized#src/};;
            esac
        fi
        printf '%s|%s|%s|%s|%s\n' "$sort_key" "$date" "$slug" "$out_path" "$image_path"
    done | sort -r
}

# Renders a <ul> list of posts
render_posts() {
    mode=$1; count=$2; page_num=${3:-1}; pagination=${4:-false}
    ul_class=$5; li_class=$6; time_class=$7; link_class=$8
    img_class=$9; show_images=${10}

    all_posts=$(collect_posts)
    # shellcheck disable=SC2181
    if [ $? -ne 0 ]; then fatal "Failed to collect posts."; fi
    total_posts=$(echo "$all_posts" | wc -l)

    printf '<ul class="%s">\n' "$ul_class"
    if [ "$mode" = "recent" ]; then
        posts_to_show=$(echo "$all_posts" | head -n "$count")
    else # mode = "all"
        start=$(((page_num - 1) * count + 1))
        end=$((page_num * count))
        posts_to_show=$(echo "$all_posts" | awk "NR>= $start && NR<= $end")
    fi
    echo "$posts_to_show" | while IFS='|' read -r _ date slug url img; do
        title=$(echo "$slug" | tr '-' ' ')
        printf '  <li class="%s">\n' "$li_class"
        if [ "$show_images" = "true" ] && [ -n "$img" ]; then
            case "$img" in
                http://*|https://*|//*) src="$img";;
                *) src="/${img}";;
            esac
            printf '    <img class="%s" src="%s" alt="%s">\n' "$img_class" "$src" "$title"
        fi
        printf '    <time class="%s" datetime="%s">%s</time>\n' "$time_class" "$date" "$date"
        printf '    <a class="%s" href="/%s">%s</a>\n' "$link_class" "${url#dist/}" "$title"
        printf '  </li>\n'
    done
    printf '</ul>\n'

    if [ "$mode" = "all" ] && [ "$pagination" = "true" ] && [ "$count" -gt 0 ]; then
        total_pages=$(((total_posts + count - 1) / count))
        if [ "$total_pages" -gt 1 ]; then
            printf '<nav class="pagination">\n'
            p=1; while [ "$p" -le "$total_pages" ]; do
                if [ "$p" -eq "$page_num" ]; then printf ' <span class="current">%d</span>' "$p"
                else printf ' <a class="page" href="?page=%d">%d</a>' "$p" "$p"; fi
                p=$((p + 1))
            done
            printf '\n</nav>\n'
        fi
    fi
}

# Replaces {{ recent-posts }} and {{ all-posts }} directives
process_post_directives() {
    # Use a marker to avoid issues with nested processing in a single pipe
    awk '/\{\{[[:space:]]*(recent-posts|all-posts)/ {
        buf=$0; while(buf!~/\}\}/ && getline) buf=buf" "$0
        gsub(/[[:space:]]+/, " ", buf); print "FSSG_DIRECTIVE::" buf; next
    } { print }' |
    while IFS= read -r line; do
        case "$line" in
            FSSG_DIRECTIVE::*)
                tag=${line#FSSG_DIRECTIVE::}
                dir=$(echo "$tag" | sed 's/^{{ *\([^ ]*\).*/\1/')
                # Helper to extract attribute values
                get_attr() { echo "$tag" | sed -n "s/.*$1=\"\([^\"]*\)\".*/\1/p"; }
                case "$dir" in
                    recent-posts)
                        render_posts "recent" \
                            "$(get_attr 'count' || echo 10)" 1 "false" \
                            "$(get_attr 'ul_class' || echo posts)" \
                            "$(get_attr 'li_class' || echo post)" \
                            "$(get_attr 'time_class' || echo date)" \
                            "$(get_attr 'link_class' || echo title)" \
                            "$(get_attr 'img_class' || echo thumb)" \
                            "$(get_attr 'show_images' || echo false)"
                        ;;
                    all-posts)
                        render_posts "all" \
                            "$(get_attr 'page_size' || echo 10)" \
                            "$(get_attr 'page' || echo 1)" \
                            "$(get_attr 'pagination' || echo false)" \
                            "$(get_attr 'ul_class' || echo posts)" \
                            "$(get_attr 'li_class' || echo post)" \
                            "$(get_attr 'time_class' || echo date)" \
                            "$(get_attr 'link_class' || echo title)" \
                            "$(get_attr 'img_class' || echo thumb)" \
                            "$(get_attr 'show_images' || echo false)"
                        ;;
                    *) printf '%s\n' "$tag" ;;
                esac ;;
            *) printf '%s\n' "$line" ;;
        esac
    done
}

# Process a single file into dist/
process_file() {
    src_file="$1"
    rel_path="${src_file#src/}"
    extension="${src_file##*.}"
    out_file="dist/${rel_path%.*}.html"

    mkdir -p "$(dirname "$out_file")"

    base_name=$(basename "$src_file" ."$extension")
    pretty_title=$(echo "$base_name" | tr '-' ' ' |
                   awk '{for(i=1;i<=NF;i++)$i=toupper(substr($i,1,1))tolower(substr($i,2));}1')

    if [ "$extension" = "md" ]; then
        raw_content=$(parse_markdown < "$src_file")
    else
        raw_content=$(cat "$src_file")
    fi

    override_title=$(echo "$raw_content" |
        awk '/\{\{ *[Tt]itle:/ {sub(/.*\{\{.*:/,"");sub(/\}\}.*/,"");print;exit}')
    final_title="${override_title:-$pretty_title}"

    page_id="${rel_path%.*}.html"
    template_file="src/template.html"
    [ ! -f "$template_file" ] && template_file="/dev/null"

    echo "$raw_content" \
        | sed 's/{{ *[Tt]itle:[^}]*}}//g' \
        | apply_template "$template_file" "$final_title" \
        | process_conditionals "$page_id" "$extension" \
        | process_includes \
        | process_post_directives \
        | process_styles_and_scripts > "$out_file"
}

# Build the full site
build_site() {
    rm -rf dist
    mkdir -p dist/static

    if [ -d src/static ]; then
        cp -R src/static/* dist/static/ 2>/dev/null || true
    fi

    tmpdir=$(mktemp -d)
    errflag=0
    running=0

    find src -type f \( -name '*.md' -o -name '*.html' \) \
        ! -path 'src/includes/*' ! -path 'src/static/*' ! -name 'template.html' |
    while IFS= read -r f; do
        log="$tmpdir/$(basename "$f").log"

        (
            if ! process_file "$f"; then
                echo "[ERROR] Failed to process $f" >&2
            fi
        ) >"$log" 2>&1 &

        running=$((running+1))

        # throttle if too many jobs running
        if [ "$running" -ge "$MAX_JOBS" ]; then
            wait
            running=0
        fi
    done

    # wait for remaining jobs
    wait

    # output only errors
    for log in "$tmpdir"/*; do
        if [ -s "$log" ]; then
            if grep -q '\[ERROR\]' "$log"; then
                cat "$log" >&2
                errflag=1
            fi
        fi
    done

    rm -rf "$tmpdir"

    if [ $errflag -eq 0 ]; then
        log_info "Build complete!"
    else
        log_error "Build finished with errors."
    fi
}

# Starts the Mongoose web server
start_server() {
    os_name=$(uname -s)
    case "$os_name" in
        CYGWIN*|MINGW*|MSYS*) mongoose_bin="./mongoose/mongoose_windows.exe" ;;
        Linux*)               mongoose_bin="./mongoose/mongoose_linux"      ;;
        Darwin*)              mongoose_bin="./mongoose/mongoose_mac"        ;;
        *)                    mongoose_bin="./mongoose/mongoose_linux"      ;;
    esac

    if [ ! -x "$mongoose_bin" ]; then
        fatal "Mongoose binary '$mongoose_bin' not found or not executable."
    fi

    "$mongoose_bin" -d dist/ -v 0 &
    SERVER_PID=$!
    log_info "Server started at http://localhost:8000 (PID: $SERVER_PID)"
    log_info "Press Ctrl+C to stop."
}

# Opens the default web browser to the local server
open_browser() {
   url="http://localhost:8000"
   case "$(uname -s)" in
     Darwin*)  open "$url" >/dev/null 2>&1 & ;;
     Linux*)   xdg-open "$url" >/dev/null 2>&1 & ;;
     CYGWIN*|MINGW*|MSYS*) start "$url" >/dev/null 2>&1 & ;;
     *)        log_info "Please open $url in your browser." ;;
   esac
}

# Cleanup function for traps
cleanup() {
    # Kill server if it was started by this script
    if [ -n "$SERVER_PID" ]; then
        kill "$SERVER_PID" 2>/dev/null || true
        log_verbose "Server with PID $SERVER_PID stopped."
    fi
}

# Calculates a checksum of all source files for change detection
get_src_hash() {
    find src -type f -print | sort | xargs cat | cksum | awk '{print $1}'
}

# Watch loop
watch_mode() {
    build_site
    last_hash=$(get_src_hash)

    if [ "$SERVE" -eq 1 ]; then
        start_server
        [ "$OPEN_BROWSER_FLAG" -eq 1 ] && open_browser
    fi

    log_verbose "Watching for file changes in src/..."
    while true; do
        sleep 1
        current_hash=$(get_src_hash)
        if [ "$current_hash" != "$last_hash" ]; then
            log_verbose "Change detected, rebuilding..."
            build_site
            last_hash="$current_hash"
            log_verbose "Watching for file changes in src/..."
        fi
    done
}

# Show help message
display_help() {
    cat <<EOF
fssg - Fast, Simple Static Site Generator (v$VERSION)
-----------------------------------------
A POSIX-compliant static site generator.

Usage:
  $(basename "$0") [options]

Options:
  -h, --help          Display this help message.
  -q, --quiet         Suppress all output except errors.
  -v, --verbose       Show detailed build information.
  -V, --version       Show version information.
  -n, --no-color      Disable colored output.
  -w, --watch         Watch for changes and rebuild automatically.
  -s, --serve         Start a local server for the dist/ directory.
  -o, --open          Open the browser automatically (requires -s).
  -j, --jobs <num>    Number of parallel jobs (default: $MAX_JOBS).
EOF
}

# Entrypoint
main() {
    # Handle internal markdown processing call
    if [ "${1:-}" = "--_md" ]; then
        parse_markdown
        exit 0
    fi

    # Set up trap to call cleanup function on script exit.
    trap 'cleanup; exit 0' EXIT INT TERM

    # Parse command-line options
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)    display_help; exit 0 ;;
            -q|--quiet)   QUIET=1; VERBOSE=0; shift ;;
            -v|--verbose) VERBOSE=1; QUIET=0; shift ;;
            -V|--version) echo "fssg version $VERSION"; exit 0 ;;
            -n|--nocolor) NO_COLOR=1; shift ;;
            -w|--watch)   WATCH=1; shift ;;
            -s|--serve)   SERVE=1; shift ;;
            -o|--open)    OPEN_BROWSER_FLAG=1; shift ;;
            -j|--jobs)
                shift
                if [ -n "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
                    MAX_JOBS="$1"; shift
                else
                    fatal "-j/--jobs requires a numeric argument."
                fi
                ;;
            --jobs=*) MAX_JOBS="${1#*=}"; shift ;;
            --) shift; break ;;
            -*) fatal "Unknown option: $1" ;;
            *) break ;;
        esac
    done

    # Setup colors
    if [ "$NO_COLOR" -eq 1 ] || ! [ -t 1 ]; then
        GREEN="" RED="" YELLOW="" BLUE="" NC=""
    else
        GREEN=$(printf '\033[0;32m')
        RED=$(printf '\033[0;31m')
        YELLOW=$(printf '\033[0;33m')
        BLUE=$(printf '\033[0;34m')
        NC=$(printf '\033[0m')
    fi

    # Main execution logic
    if [ "$WATCH" -eq 1 ]; then
        watch_mode
    else
        build_site
        if [ "$SERVE" -eq 1 ]; then
            start_server
            [ "$OPEN_BROWSER_FLAG" -eq 1 ] && open_browser
            wait "$SERVER_PID"
        fi
    fi
}

main "$@"
