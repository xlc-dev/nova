<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Middleware - nova</title>


    <!-- Custom HTML head -->

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

    <!-- MathJax -->
    <script async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
    </script>
    <!-- Start loading toc.js asap -->
    <script src="toc.js"></script>
</head>

<body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nova</h1>

                    <div class="right-buttons">

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="middleware"><a class="header" href="#middleware">Middleware</a></h1>
<p>Nova has ready-to-use middleware for <code>net/http</code>. In this document, you will find the list of built-in middleware and how to use them.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#what-is-middleware">What is Middleware?</a></li>
<li><a href="#custom-middleware">Custom Middleware</a></li>
<li><a href="#built-in-middleware">Built-in Middleware</a>
<ul>
<li><a href="#loggingmiddleware">LoggingMiddleware</a></li>
<li><a href="#recoverymiddleware">RecoveryMiddleware</a></li>
<li><a href="#requestidmiddleware">RequestIDMiddleware</a></li>
<li><a href="#corsmiddleware">CORSMiddleware</a></li>
<li><a href="#securityheadersmiddleware">SecurityHeadersMiddleware</a></li>
<li><a href="#timeoutmiddleware">TimeoutMiddleware</a></li>
<li><a href="#basicauthmiddleware">BasicAuthMiddleware</a></li>
<li><a href="#methodoverridemiddleware">MethodOverrideMiddleware</a></li>
<li><a href="#enforcecontenttypemiddleware">EnforceContentTypeMiddleware</a></li>
<li><a href="#cachecontrolmiddleware">CacheControlMiddleware</a></li>
<li><a href="#gzipmiddleware">GzipMiddleware</a></li>
<li><a href="#csrfmiddleware">CSRFMiddleware</a></li>
<li><a href="#ETagMiddleware">ETagMiddleware</a></li>
<li><a href="#healthcheckmiddleware">HealthCheckMiddleware</a></li>
<li><a href="#realipmiddleware">RealIPMiddleware</a></li>
<li><a href="#maxrequestbodysizemiddleware">MaxRequestBodySizeMiddleware</a></li>
<li><a href="#trailingslashredirectmiddleware">TrailingSlashRedirectMiddleware</a></li>
<li><a href="#forcehttpsmiddleware">ForceHTTPSMiddleware</a></li>
<li><a href="#concurrencylimitermiddleware">ConcurrencyLimiterMiddleware</a></li>
<li><a href="#maintenancemodemiddleware">MaintenanceModeMiddleware</a></li>
<li><a href="#ipfiltermiddleware">IPFilterMiddleware</a></li>
<li><a href="#ratelimitmiddleware">RateLimitMiddleware</a></li>
</ul>
</li>
</ol>
<h2 id="what-is-middleware"><a class="header" href="#what-is-middleware">What is Middleware?</a></h2>
<p>In the context of Nova’s web handling capabilities (using Go’s standard <code>net/http</code> package), <strong>middleware</strong> refers to a function that wraps an <code>http.Handler</code>. It follows the standard Go pattern: a function that takes an <code>http.Handler</code> and returns a new <code>http.Handler</code>.</p>
<pre><code class="language-go">// Middleware defines the function signature for middleware.
// A middleware is a function that wraps an http.Handler, adding extra behavior.
type Middleware func(http.Handler) http.Handler
</code></pre>
<p>Middleware functions sit between the server’s routing logic (like <code>nova.Router</code>) and your final request handler (<code>http.HandlerFunc</code>). They provide a way to process the <code>http.Request</code> and <code>http.ResponseWriter</code> or perform actions <em>before</em> or <em>after</em> your main handler logic runs.</p>
<p>Think of it like layers processing an incoming HTTP request:</p>
<ol>
<li>An HTTP request arrives.</li>
<li>Nova’s router directs the request towards the appropriate handler.</li>
<li>If middleware is applied (e.g., via <code>router.Use(...)</code>), the request passes through each middleware function in sequence.</li>
<li>Each middleware can:
<ul>
<li>Examine or modify the <code>http.Request</code> (e.g., add context values, parse headers).</li>
<li>Wrap the <code>http.ResponseWriter</code> to intercept or modify the response (e.g., capture status code, compress data).</li>
<li>Perform tasks like logging, timing, authentication checks, authorization, rate limiting, or setting common headers.</li>
<li>Decide whether to pass control to the <code>next</code> handler in the chain by calling <code>next.ServeHTTP(w, r)</code>.</li>
<li>Perform tasks <em>after</em> the <code>next</code> handler has completed (e.g., logging the response status, cleanup).</li>
</ul>
</li>
<li>Finally, the core <code>http.HandlerFunc</code> for the route is executed (if the middleware chain allowed it).</li>
</ol>
<p><strong>Key Benefits of Using Middleware:</strong></p>
<ul>
<li><strong>Separation of Concerns:</strong> Keeps cross-cutting logic (like logging, authentication, compression, security headers) separate from your core request handling logic, making handlers cleaner and more focused.</li>
<li><strong>Reusability:</strong> Write common pre-processing or post-processing logic once as middleware and apply it to multiple routes or groups of routes easily using <code>router.Use(...)</code> or <code>group.Use(...)</code>.</li>
<li><strong>Composability:</strong> Chain multiple, small middleware functions together to build complex request processing pipelines in a modular and maintainable way.</li>
</ul>
<p>This pattern is fundamental to building web applications and APIs in Go.</p>
<h2 id="custom-middleware"><a class="header" href="#custom-middleware">Custom Middleware</a></h2>
<p>You can easily create your own middleware by defining a function that matches the <code>nova.Middleware</code> type signature:</p>
<pre><code class="language-go">type Middleware func(http.Handler) http.Handler
</code></pre>
<p>Here’s a simple example of a custom middleware that adds a custom header to every response:</p>
<pre><code class="language-go">// CustomHeaderMiddleware adds a "X-Custom-Header" to responses.
func CustomHeaderMiddleware(headerName, headerValue string) nova.Middleware {
    // Return the actual middleware function
    return func(next http.Handler) http.Handler {
        // Return the HandlerFunc that wraps the next handler
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Set the header before calling the next handler
            w.Header().Set(headerName, headerValue)

            // Call the next middleware or handler in the chain
            next.ServeHTTP(w, r)

            // Could also perform actions *after* the handler runs here
        })
    }
}

// And then somewhere else where you want to use it on a router/group/subrouter:
router.Use(CustomHeaderMiddleware("X-App-Version", "1.2.3"))
</code></pre>
<h2 id="built-in-middleware"><a class="header" href="#built-in-middleware">Built-in Middleware</a></h2>
<p>Nova provides a collection of standard <code>net/http</code> middleware. Each middleware is typically configured using a specific <code>Config</code> struct and applied using <code>router.Use(...)</code> for global application or <code>group.Use(...)</code> for group-specific application.</p>
<hr />
<h3 id="loggingmiddleware"><a class="header" href="#loggingmiddleware">LoggingMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Logs incoming requests (start) and outgoing responses (completion), including method, path, remote address, status code, response size, and duration.</li>
<li><strong>Configuration:</strong> <code>nova.LoggingConfig</code>
<ul>
<li><code>Logger *log.Logger</code>: Logger instance (defaults to <code>log.Default()</code>).</li>
<li><code>LogRequestID bool</code>: Include request ID in logs (defaults to true). Requires <code>RequestIDMiddleware</code>.</li>
<li><code>RequestIDKey contextKey</code>: Context key for request ID (defaults to internal key).</li>
</ul>
</li>
</ul>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()
	customLogger := log.New(os.Stdout, "[ACCESS] ", log.LstdFlags)

	// Apply logging middleware
	router.Use(nova.LoggingMiddleware(&amp;nova.LoggingConfig{
		Logger:       customLogger,
		LogRequestID: true, // Optional: Explicitly true (default)
	}))
	// Apply RequestID middleware if LogRequestID is true
	router.Use(nova.RequestIDMiddleware(nil)) // Use defaults
}
</code></pre>
<hr />
<h3 id="recoverymiddleware"><a class="header" href="#recoverymiddleware">RecoveryMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Recovers from panics in downstream handlers/middleware, logs the panic, and sends a 500 Internal Server Error response (or calls a custom handler).</li>
<li><strong>Configuration:</strong> <code>nova.RecoveryConfig</code>
<ul>
<li><code>Logger *log.Logger</code>: Logger for panic messages (defaults to <code>log.Default()</code>).</li>
<li><code>LogRequestID bool</code>: Include request ID in panic logs (defaults to true).</li>
<li><code>RequestIDKey contextKey</code>: Context key for request ID (defaults to internal key).</li>
<li><code>RecoveryHandler func(http.ResponseWriter, *http.Request, interface{})</code>: Custom function to handle recovered panics.</li>
</ul>
</li>
</ul>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><code class="language-go">func customPanicHandler(w http.ResponseWriter, r *http.Request, err interface{}) {
	reqID := nova.GetRequestID(r.Context()) // Get request ID if available
	log.Printf("[PANIC RECOVERY][%s] Custom handler called: %v", reqID, err)
	http.Error(w, "Something went terribly wrong!", http.StatusInternalServerError)
}

func main() {
	router := nova.NewRouter()

	// Apply RequestID first so Recovery can log it
	router.Use(nova.RequestIDMiddleware(nil))

	// Apply recovery middleware (must be early in the chain, so it can set the recover mechanism)
	router.Use(nova.RecoveryMiddleware(&amp;nova.RecoveryConfig{
		RecoveryHandler: customPanicHandler,
		LogRequestID:    true,
	}))

	router.Get("/panic", func(w http.ResponseWriter, r *http.Request) {
		panic("Simulating a handler panic!")
	})

	router.Get("/safe", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("This is fine."))
	})

	log.Println("Starting server on :8080")
	http.ListenAndServe(":8080", router)
}
</code></pre>
<hr />
<h3 id="requestidmiddleware"><a class="header" href="#requestidmiddleware">RequestIDMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Assigns a unique ID to each request (from header or generated), sets it in the response header, and adds it to the request context.</li>
<li><strong>Configuration:</strong> <code>nova.RequestIDConfig</code>
<ul>
<li><code>HeaderName string</code>: Header to check/set (defaults to <code>X-Request-ID</code>).</li>
<li><code>ContextKey contextKey</code>: Context key for storage (defaults to internal key).</li>
<li><code>Generator func() string</code>: ID generation function (defaults to timestamp-based).</li>
</ul>
</li>
<li><strong>Context Helper:</strong> <code>nova.GetRequestID(ctx context.Context)</code> retrieves the ID.</li>
</ul>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply RequestID middleware globally
	router.Use(nova.RequestIDMiddleware(&amp;nova.RequestIDConfig{
		HeaderName: "X-Trace-ID", // Custom header name
		Generator: func() string { // Custom generator (e.g., UUID)
			return uuid.NewString() // From github.com/google/uuid
		},
	}))

	router.Get("/whoami", func(w http.ResponseWriter, r *http.Request) {
		reqID := nova.GetRequestID(r.Context())
		fmt.Fprintf(w, "Your request ID is: %s", reqID)
	})
}
</code></pre>
<hr />
<h3 id="corsmiddleware"><a class="header" href="#corsmiddleware">CORSMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Handles Cross-Origin Resource Sharing (CORS) by setting <code>Access-Control-*</code> headers and managing preflight <code>OPTIONS</code> requests.</li>
<li><strong>Configuration:</strong> <code>nova.CORSConfig</code>
<ul>
<li><code>AllowedOrigins []string</code>: Allowed origin domains (e.g., <code>["http://localhost:3000"]</code>, <code>["*"]</code>). Defaults to none.</li>
<li><code>AllowedMethods []string</code>: Allowed HTTP methods (defaults to GET, POST, PUT, DELETE, PATCH, OPTIONS).</li>
<li><code>AllowedHeaders []string</code>: Allowed request headers (defaults to Content-Type, Authorization, X-Request-ID). <code>"*"</code> allows any.</li>
<li><code>ExposedHeaders []string</code>: Response headers accessible to the client script. Defaults to none.</li>
<li><code>AllowCredentials bool</code>: Allow cookies/auth headers with requests (defaults to false). Cannot be true if <code>AllowedOrigins</code> is <code>["*"]</code>.</li>
<li><code>MaxAgeSeconds int</code>: Cache duration for preflight results (defaults to 86400).</li>
</ul>
</li>
</ul>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply CORS middleware globally
	// OPTIONS requests are handled automatically by the middleware
	router.Use(nova.CORSMiddleware(nova.CORSConfig{
		AllowedOrigins:   []string{"http://localhost:3000", "https://my-frontend.com"},
		AllowedMethods:   []string{"GET", "POST", "OPTIONS"},
		AllowedHeaders:   []string{"Content-Type", "Authorization"},
		ExposedHeaders:   []string{"X-Custom-Response-Header"},
		AllowCredentials: true,
		MaxAgeSeconds:    3600, // 1 hour
	}))

	router.Get("/api/data", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("X-Custom-Response-Header", "SomeValue")
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte(`{"message": "Data from API"}`))
	})
}
</code></pre>
<hr />
<h3 id="securityheadersmiddleware"><a class="header" href="#securityheadersmiddleware">SecurityHeadersMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Sets various HTTP security headers (CSP, HSTS, X-Frame-Options, etc.) to enhance application security.</li>
<li><strong>Configuration:</strong> <code>nova.SecurityHeadersConfig</code> (all fields optional, have sensible defaults)
<ul>
<li><code>ContentTypeOptions string</code>: Defaults to <code>nosniff</code>.</li>
<li><code>FrameOptions string</code>: Defaults to <code>DENY</code>.</li>
<li><code>XSSProtection string</code>: Defaults to <code>1; mode=block</code>.</li>
<li><code>ReferrerPolicy string</code>: Defaults to <code>strict-origin-when-cross-origin</code>.</li>
<li><code>HSTSMaxAgeSeconds int</code>: Enables HSTS if &gt; 0 (defaults to 0).</li>
<li><code>HSTSIncludeSubdomains *bool</code>: Defaults to true if HSTS enabled.</li>
<li><code>HSTSPreload bool</code>: Defaults to false.</li>
<li><code>ContentSecurityPolicy string</code>: Defaults to <code>""</code>. <strong>Important:</strong> Define a policy specific to your app.</li>
<li><code>PermissionsPolicy string</code>: Defaults to <code>""</code>.</li>
</ul>
</li>
</ul>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	hstsEnabled := true // Example: Enable HSTS

	// Apply Security Headers middleware globally
	router.Use(nova.SecurityHeadersMiddleware(nova.SecurityHeadersConfig{
		// Example: Define a basic Content Security Policy
		ContentSecurityPolicy: "default-src 'self'; script-src 'self'; object-src 'none';",
		// Example: Enable HSTS for 1 year
		HSTSMaxAgeSeconds:     int(365 * 24 * time.Hour.Seconds()),
		HSTSIncludeSubdomains: &amp;hstsEnabled, // Explicitly enable (default if HSTSMaxAgeSeconds &gt; 0)
		// HSTSPreload: true, // Use with caution after submission
		// PermissionsPolicy: "geolocation=(), microphone=()", // Example policy
	}))

	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html")
		w.Write([]byte("&lt;h1&gt;Secure Page&lt;/h1&gt;"))
	})
}
</code></pre>
<hr />
<h3 id="timeoutmiddleware"><a class="header" href="#timeoutmiddleware">TimeoutMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Enforces a maximum duration for request handling. Cancels the request context and returns 503 Service Unavailable (or calls custom handler) on timeout.</li>
<li><strong>Configuration:</strong> <code>nova.TimeoutConfig</code>
<ul>
<li><code>Duration time.Duration</code>: Maximum processing time (required if used).</li>
<li><code>TimeoutMessage string</code>: Response body on timeout (defaults to “Service timed out”).</li>
<li><code>TimeoutHandler http.Handler</code>: Custom handler for timeout events.</li>
</ul>
</li>
</ul>
<h4 id="example-5"><a class="header" href="#example-5">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Timeout middleware globally
	router.Use(nova.TimeoutMiddleware(nova.TimeoutConfig{
		Duration: 5 * time.Second, // Set a 5-second timeout
		// TimeoutMessage: "Request took too long!", // Optional custom message
		// TimeoutHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// 	http.Error(w, "Custom timeout response", http.StatusGatewayTimeout)
		// }), // Optional custom handler
	}))

	router.Get("/slow", func(w http.ResponseWriter, r *http.Request) {
		log.Println("Slow handler started...")
		select {
		case &lt;-time.After(10 * time.Second): // Simulate work longer than timeout
			log.Println("Slow handler finished (too late).")
			w.Write([]byte("Finished slow task."))
		case &lt;-r.Context().Done(): // Context cancelled by timeout middleware
			log.Println("Slow handler cancelled by timeout.")
			// Note: Cannot write response here, middleware handles it.
			return
		}
	})

	router.Get("/fast", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Finished quickly."))
	})
}
</code></pre>
<hr />
<h3 id="basicauthmiddleware"><a class="header" href="#basicauthmiddleware">BasicAuthMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Protects routes using HTTP Basic Authentication, validating credentials with a provided function.</li>
<li><strong>Configuration:</strong> <code>nova.BasicAuthConfig</code>
<ul>
<li><code>Realm string</code>: Authentication realm (defaults to “Restricted”).</li>
<li><code>Validator AuthValidator</code>: Function <code>func(user, pass string) bool</code> (required).</li>
<li><code>StoreUserInContext bool</code>: Store authenticated user in context (defaults to false).</li>
<li><code>ContextKey contextKey</code>: Context key for user (defaults to internal key).</li>
</ul>
</li>
<li><strong>Context Helper:</strong> <code>nova.GetBasicAuthUser(ctx context.Context)</code> retrieves the user if stored.</li>
</ul>
<h4 id="example-6"><a class="header" href="#example-6">Example</a></h4>
<pre><code class="language-go">// Simple validator function (replace with real logic)
func myAuthValidator(username, password string) bool {
	// WARNING: Hardcoded credentials are insecure! Use a proper check.
	return username == "admin" &amp;&amp; password == "password123"
}

func main() {
	router := nova.NewRouter()

	// Apply Basic Auth middleware globally or to a group
	authMiddleware := nova.BasicAuthMiddleware(nova.BasicAuthConfig{
		Validator:          myAuthValidator,
		Realm:              "My Protected Area",
		StoreUserInContext: true, // Store the username
	})
	router.Use(authMiddleware) // Apply globally

	// Alternatively, apply to a group:
	// adminGroup := router.Group("/admin")
	// adminGroup.Use(authMiddleware)
	// adminGroup.Get("/dashboard", ...)

	router.Get("/secure", func(w http.ResponseWriter, r *http.Request) {
		user := nova.GetBasicAuthUser(r.Context())
		fmt.Fprintf(w, "Welcome, authenticated user: %s", user)
	})

	log.Println("Starting server on :8080")
	http.ListenAndServe(":8080", router)
}
</code></pre>
<hr />
<h3 id="methodoverridemiddleware"><a class="header" href="#methodoverridemiddleware">MethodOverrideMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Allows overriding the HTTP method via a header (<code>X-HTTP-Method-Override</code>) or form field (<code>_method</code> for POST requests).</li>
<li><strong>Configuration:</strong> <code>nova.MethodOverrideConfig</code>
<ul>
<li><code>HeaderName string</code>: Header to check (defaults to <code>X-HTTP-Method-Override</code>).</li>
<li><code>FormFieldName string</code>: Form field to check (defaults to <code>_method</code>). Set to <code>""</code> to disable form field check.</li>
</ul>
</li>
</ul>
<h4 id="example-7"><a class="header" href="#example-7">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Method Override middleware globally
	router.Use(nova.MethodOverrideMiddleware(nil)) // Use defaults

	// Handler that might receive overridden methods
	router.Post("/resource", func(w http.ResponseWriter, r *http.Request) {
		// r.Method will be the overridden method (e.g., PUT, DELETE)
		fmt.Fprintf(w, "Handling resource with method: %s", r.Method)
	})
	// Need corresponding handlers for the methods you expect to be overridden
	router.Put("/resource", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Handling resource with method: PUT (via override or direct)")
	})
	router.Delete("/resource", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Handling resource with method: DELETE (via override or direct)")
	})


	log.Println("Starting server on :8080")
	http.ListenAndServe(":8080", router)
}
// Example client request using header:
// curl -X POST -H "X-HTTP-Method-Override: DELETE" http://localhost:8080/resource

// Example client request using form field (HTML form):
// &lt;form action="/resource" method="POST"&gt;
//   &lt;input type="hidden" name="_method" value="PUT"&gt;
//   &lt;button type="submit"&gt;Update Resource&lt;/button&gt;
// &lt;/form&gt;
</code></pre>
<hr />
<h3 id="enforcecontenttypemiddleware"><a class="header" href="#enforcecontenttypemiddleware">EnforceContentTypeMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Ensures requests for specific methods (POST, PUT, PATCH by default) have a <code>Content-Type</code> header matching an allowed list.</li>
<li><strong>Configuration:</strong> <code>nova.EnforceContentTypeConfig</code>
<ul>
<li><code>AllowedTypes []string</code>: List of allowed Content-Types (e.g., <code>["application/json"]</code>) (required).</li>
<li><code>MethodsToCheck []string</code>: Methods to check (defaults to POST, PUT, PATCH).</li>
<li><code>OnError func(w http.ResponseWriter, r *http.Request, err error)</code>: Custom error handler.</li>
</ul>
</li>
</ul>
<h4 id="example-8"><a class="header" href="#example-8">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Content-Type enforcement globally or to relevant groups/routes
	router.Use(nova.EnforceContentTypeMiddleware(nova.EnforceContentTypeConfig{
		AllowedTypes: []string{"application/json", "application/xml"},
		// MethodsToCheck: []string{"POST"}, // Optional: Only check POST
	}))

	router.Post("/submit", func(w http.ResponseWriter, r *http.Request) {
		// Handler logic assumes Content-Type is valid here
		w.Write([]byte("Data submitted successfully."))
	})

	router.Get("/fetch", func(w http.ResponseWriter, r *http.Request) {
		// GET requests are not checked by default
		w.Write([]byte("Data fetched."))
	})
}
// Example failing request:
// curl -X POST -d 'data' http://localhost:8080/submit
// -&gt; 400 Bad Request (Missing Content-Type)

// Example failing request:
// curl -X POST -H "Content-Type: text/plain" -d 'data' http://localhost:8080/submit
// -&gt; 415 Unsupported Media Type

// Example successful request:
// curl -X POST -H "Content-Type: application/json" -d '{"key":"value"}' http://localhost:8080/submit
// -&gt; 200 OK
</code></pre>
<hr />
<h3 id="cachecontrolmiddleware"><a class="header" href="#cachecontrolmiddleware">CacheControlMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Sets the <code>Cache-Control</code> header on all responses.</li>
<li><strong>Configuration:</strong> <code>nova.CacheControlConfig</code>
<ul>
<li><code>CacheControlValue string</code>: The value for the header (e.g., “no-store”) (required).</li>
</ul>
</li>
</ul>
<h4 id="example-9"><a class="header" href="#example-9">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Cache-Control middleware globally
	router.Use(nova.CacheControlMiddleware(nova.CacheControlConfig{
		CacheControlValue: "no-store, no-cache, must-revalidate",
	}))

	router.Get("/api/status", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("OK"))
	})
}
</code></pre>
<hr />
<h3 id="gzipmiddleware"><a class="header" href="#gzipmiddleware">GzipMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Compresses response bodies using gzip if the client supports it (<code>Accept-Encoding: gzip</code>). Uses a <code>sync.Pool</code> for <code>gzip.Writer</code> reuse to improve performance.</li>
<li><strong>Configuration:</strong> <code>nova.GzipConfig</code>
<ul>
<li><code>CompressionLevel int</code>: Gzip level (e.g., <code>gzip.BestSpeed</code>, <code>gzip.DefaultCompression</code>, <code>gzip.BestCompression</code>). Defaults to <code>gzip.DefaultCompression</code> (-1).</li>
<li><code>AddVaryHeader *bool</code>: Adds <code>Vary: Accept-Encoding</code> header. Defaults to <code>true</code>. Use <code>new(bool)</code> to set explicitly (e.g., <code>AddVaryHeader: new(bool) // false</code>).</li>
<li><code>Logger *log.Logger</code>: Optional logger for errors. Defaults to <code>log.Default()</code>.</li>
<li><code>Pool *sync.Pool</code>: Optional <code>sync.Pool</code> for <code>gzip.Writer</code> reuse. Defaults to an internal pool.</li>
</ul>
</li>
</ul>
<h4 id="example-10"><a class="header" href="#example-10">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Custom pool example (optional)
	gzipPool := &amp;sync.Pool{
		New: func() interface{} {
			gw, _ := gzip.NewWriterLevel(io.Discard, gzip.BestSpeed)
			return gw
		},
	}

	// Apply Gzip middleware globally
	router.Use(nova.GzipMiddleware(&amp;nova.GzipConfig{
		CompressionLevel: gzip.BestSpeed, // Optional: Prioritize speed
		// AddVaryHeader:    func() *bool { b := false; return &amp;b }(), // Explicitly disable Vary
		Pool:             gzipPool,       // Optional: Use custom pool
	}))

	router.Get("/large-data", func(w http.ResponseWriter, r *http.Request) {
		// Simulate a large response
		w.Header().Set("Content-Type", "text/plain; charset=utf-8")
		for i := 0; i &lt; 1000; i++ {
			w.Write([]byte("This is line number "))
			w.Write([]byte(http.StatusText(i + 200)))
			w.Write([]byte("\n"))
		}
}

// Example request:
// curl -H "Accept-Encoding: gzip" http://localhost:8080/large-data --output - | gunzip
</code></pre>
<hr />
<h3 id="csrfmiddleware"><a class="header" href="#csrfmiddleware">CSRFMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Provides Cross-Site Request Forgery (CSRF) protection using the Double Submit Cookie pattern. It sets a secure, HttpOnly cookie and expects a matching token in a header or form field for unsafe HTTP methods (POST, PUT, DELETE, etc.).</li>
<li><strong>Configuration:</strong> <code>nova.CSRFConfig</code>
<ul>
<li><code>Logger *log.Logger</code>: Optional logger. Defaults to <code>log.Default()</code>.</li>
<li><code>FieldName string</code>: Form field name for the token. Defaults to <code>"csrf_token"</code>.</li>
<li><code>HeaderName string</code>: HTTP header name for the token. Defaults to <code>"X-CSRF-Token"</code>.</li>
<li><code>CookieName string</code>: Name of the HttpOnly cookie storing the secret. Defaults to <code>"_csrf"</code>.</li>
<li><code>ContextKey contextKey</code>: Context key to store the expected token. Defaults to internal package key.</li>
<li><code>ErrorHandler http.HandlerFunc</code>: Handler called on CSRF failure. Defaults to 403 Forbidden.</li>
<li><code>CookiePath string</code>: Path for the CSRF cookie. Defaults to <code>"/"</code>.</li>
<li><code>CookieDomain string</code>: Domain for the CSRF cookie. Defaults to <code>""</code>.</li>
<li><code>CookieMaxAge time.Duration</code>: Max age of the cookie. Defaults to 12 hours.</li>
<li><code>CookieSecure bool</code>: Secure flag for the cookie (requires HTTPS). Defaults to <code>false</code>. <strong>Set to <code>true</code> in production.</strong></li>
<li><code>CookieSameSite http.SameSite</code>: SameSite attribute. Defaults to <code>http.SameSiteLaxMode</code>.</li>
<li><code>TokenLength int</code>: Byte length of the generated token. Defaults to 32.</li>
<li><code>SkipMethods []string</code>: HTTP methods exempt from checks. Defaults to <code>["GET", "HEAD", "OPTIONS", "TRACE"]</code>.</li>
</ul>
</li>
</ul>
<h4 id="example-11"><a class="header" href="#example-11">Example</a></h4>
<pre><code class="language-go">// Simple template to include CSRF token
var formTmpl = template.Must(template.New("form").Parse(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
	&lt;h2&gt;CSRF Demo Form&lt;/h2&gt;
	&lt;form method="POST" action="/submit"&gt;
		&lt;input type="hidden" name="csrf_token" value="{{.}}"&gt;
		&lt;label for="data"&gt;Data:&lt;/label&gt;
		&lt;input type="text" id="data" name="data"&gt;
		&lt;button type="submit"&gt;Submit&lt;/button&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
`))

func main() {
	router := nova.NewRouter()

	// Apply CSRF middleware
	router.Use(nova.CSRFMiddleware(&amp;nova.CSRFConfig{
		CookieSecure:   false, // Set to true if using HTTPS
		CookieSameSite: http.SameSiteStrictMode, // Often preferred
		// ErrorHandler: func(w http.ResponseWriter, r *http.Request) { ... }, // Custom error
	}))

	// Handler to display the form
	router.Get("/form", func(w http.ResponseWriter, r *http.Request) {
		// Get the token set by the middleware via context helper
		csrfToken := nova.GetCSRFToken(r.Context())
		w.Header().Set("Content-Type", "text/html")
		formTmpl.Execute(w, csrfToken) // Pass token to template
	})

	// Handler to process the form submission
	router.Post("/submit", func(w http.ResponseWriter, r *http.Request) {
		data := r.FormValue("data")
		fmt.Fprintf(w, "Received data: %s", data)
	})
}

// Example request (simulating a valid POST after getting the form):
// 1. Get form to get cookie and token: curl -c cookies.txt http://localhost:8080/form
// 2. Extract token from HTML output (e.g., TOKEN_VALUE)
// 3. Make POST request with cookie and token header:
//    curl -b cookies.txt -X POST -H "X-CSRF-Token: TOKEN_VALUE" -d "data=hello" http://localhost:8080/submit
// Example request (simulating a failed POST - missing token):
// curl -b cookies.txt -X POST -d "data=hello" http://localhost:8080/submit
// Response: Forbidden
</code></pre>
<hr />
<h3 id="etagmiddleware"><a class="header" href="#etagmiddleware">ETagMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Adds an <code>ETag</code> header to successful responses based on a hash of the response body. Handles <code>If-None-Match</code> conditional requests, potentially returning a <code>304 Not Modified</code> status without the response body if the client’s cached ETag matches. <strong>Note:</strong> This middleware buffers the entire response body in memory to calculate the hash, which may be unsuitable for very large responses.</li>
<li><strong>Configuration:</strong> <code>nova.ETagConfig</code>
<ul>
<li><code>Weak bool</code>: Generate weak ETags (prefixed with <code>W/</code>). Defaults to <code>false</code> (strong ETags).</li>
<li><code>SkipNoContent bool</code>: Skip ETag generation/checking for <code>204 No Content</code> responses. Defaults to <code>true</code>.</li>
</ul>
</li>
</ul>
<h4 id="example-12"><a class="header" href="#example-12">Example</a></h4>
<pre><code class="language-go">var lastModified = time.Now()
var responseBody = "Initial content"

func main() {
	router := nova.NewRouter()

	// Apply ETag middleware
	router.Use(nova.ETagMiddleware(&amp;nova.ETagConfig{
		// Weak: true, // Optional: Use weak ETags
	}))

	router.Get("/content", func(w http.ResponseWriter, r *http.Request) {
		// Simulate content that might change
		w.Header().Set("Content-Type", "text/plain")
		w.Header().Set("Cache-Control", "max-age=60") // Advise caching
		fmt.Fprint(w, responseBody)
	})

	// Example route to change the content
	router.Get("/update", func(w http.ResponseWriter, r *http.Request) {
		responseBody = fmt.Sprintf("Content updated at %s", time.Now())
		lastModified = time.Now()
		fmt.Fprint(w, "Content updated. Try /content again.")
	})
}

// Example requests:
// 1. First request: curl -v http://localhost:8080/content
//    (Note the ETag header in the response, e.g., ETag: "HASH_VALUE")
// 2. Second request (client sends If-None-Match):
//    curl -v -H 'If-None-Match: "HASH_VALUE"' http://localhost:8080/content
//    (Response should be 304 Not Modified with an empty body)
// 3. Update content: curl http://localhost:8080/update
// 4. Request again with old ETag:
//    curl -v -H 'If-None-Match: "HASH_VALUE"' http://localhost:8080/content
//    (Response should be 200 OK with the new content and a *new* ETag)
</code></pre>
<hr />
<h3 id="healthcheckmiddleware"><a class="header" href="#healthcheckmiddleware">HealthCheckMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Provides a dedicated health check endpoint (e.g., <code>/healthz</code>). Requests to this path are handled directly by the middleware (returning a status, often 200 OK), bypassing subsequent middleware and application handlers. Useful for load balancers and monitoring systems.</li>
<li><strong>Configuration:</strong> <code>nova.HealthCheckConfig</code>
<ul>
<li><code>Path string</code>: The URL path for the health check endpoint. Defaults to <code>"/healthz"</code>.</li>
<li><code>Handler http.HandlerFunc</code>: The handler function to execute for the health check. If nil, a default handler returning 200 OK with “OK” body is used. Can be customized to check database connections, etc.</li>
</ul>
</li>
</ul>
<h4 id="example-13"><a class="header" href="#example-13">Example</a></h4>
<pre><code class="language-go">// Example custom health check handler
func customHealthHandler(w http.ResponseWriter, r *http.Request) {
	// Simulate checking a dependency (e.g., database)
	time.Sleep(10 * time.Millisecond)
	isHealthy := true // Replace with actual check logic

	if isHealthy {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		fmt.Fprintln(w, `{"status": "UP"}`)
	} else {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusServiceUnavailable)
		fmt.Fprintln(w, `{"status": "DOWN", "reason": "database connection failed"}`)
	}
}

func main() {
	router := nova.NewRouter()

	// Apply HealthCheck middleware (often placed early, but after recovery/logging if needed)
	router.Use(nova.HealthCheckMiddleware(&amp;nova.HealthCheckConfig{
		Path:    "/status",             // Optional: Custom path
		Handler: customHealthHandler, // Optional: Custom check logic
	}))

	// Other middleware and routes...
	router.Use(nova.LoggingMiddleware(nil)) // Example: Log other requests

	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Main application page")
	})
}

// Example requests:
// curl http://localhost:8080/status
// Response (with custom handler): {"status": "UP"}
// curl http://localhost:8080/
// Response: Main application page (Logs will show this request, but not the /status request if logging is after health check)
</code></pre>
<hr />
<h3 id="realipmiddleware"><a class="header" href="#realipmiddleware">RealIPMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Extracts the client’s real IP address from trusted proxy headers (e.g., <code>X-Forwarded-For</code>, <code>X-Real-IP</code>). <strong>Warning:</strong> Only use behind a trusted proxy.</li>
<li><strong>Configuration:</strong> <code>nova.RealIPConfig</code>
<ul>
<li><code>TrustedProxyCIDRs []string</code>: CIDR ranges of trusted proxies (e.g., <code>["10.0.0.0/8", "192.168.1.1/32"]</code>). Required for header trusting.</li>
<li><code>IPHeaders []string</code>: Headers to check in order (defaults to <code>X-Forwarded-For</code>, <code>X-Real-IP</code>).</li>
<li><code>StoreInContext bool</code>: Store the real IP in context (defaults to true).</li>
<li><code>ContextKey contextKey</code>: Context key for IP (defaults to internal key).</li>
</ul>
</li>
<li><strong>Context Helper:</strong> <code>nova.GetRealIP(ctx context.Context)</code> retrieves the IP.</li>
<li><strong>Usage:</strong></li>
</ul>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply RealIP middleware globally (ensure it runs early)
	router.Use(nova.RealIPMiddleware(nova.RealIPConfig{
		// IMPORTANT: Only list CIDRs of proxies you TRUST
		TrustedProxyCIDRs: []string{"127.0.0.1/32", "::1/128"}, // Example: Trust localhost proxy
		IPHeaders:         []string{"X-Forwarded-For", "X-Real-IP"}, // Default
		StoreInContext:    true, // Default
	}))

	// Apply Logging middleware *after* RealIP so logs show the real IP
	router.Use(nova.LoggingMiddleware(nil))

	router.Get("/ip", func(w http.ResponseWriter, r *http.Request) {
		realIP := nova.GetRealIP(r.Context())
		// r.RemoteAddr might also be updated (with port 0) if IP found via header
		fmt.Fprintf(w, "Your detected IP: %s\n", realIP)
		fmt.Fprintf(w, "Request RemoteAddr: %s\n", r.RemoteAddr)
	})
}
// Example request (simulating proxy):
// curl -H "X-Forwarded-For: 1.2.3.4" http://localhost:8080/ip
</code></pre>
<hr />
<h3 id="maxrequestbodysizemiddleware"><a class="header" href="#maxrequestbodysizemiddleware">MaxRequestBodySizeMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Limits the size of incoming request bodies using <code>http.MaxBytesReader</code>.</li>
<li><strong>Configuration:</strong> <code>nova.MaxRequestBodySizeConfig</code>
<ul>
<li><code>LimitBytes int64</code>: Maximum body size in bytes (required).</li>
<li><code>OnError func(w http.ResponseWriter, r *http.Request)</code>: Custom error handler (defaults to 413 response).</li>
</ul>
</li>
</ul>
<h4 id="example-14"><a class="header" href="#example-14">Example</a></h4>
<pre><code class="language-go">
func main() {
	router := nova.NewRouter()

	// Apply Max Body Size middleware globally or to upload routes
	router.Use(nova.MaxRequestBodySizeMiddleware(nova.MaxRequestBodySizeConfig{
		LimitBytes: 1 * 1024 * 1024, // 1 MB limit
		// OnError: func(w http.ResponseWriter, r *http.Request) {
		// 	http.Error(w, "Request body too large!", http.StatusRequestEntityTooLarge)
		// }, // Optional custom handler
	}))

	router.Post("/upload", func(w http.ResponseWriter, r *http.Request) {
		// Attempt to read the body. MaxBytesReader will return an error
		// if the limit is exceeded during the read.
		bodyBytes, err := io.ReadAll(r.Body)
		if err != nil {
			// Error might be due to size limit or other read issues.
			// The middleware's default OnError usually handles the 413 response
			// before the handler even gets here if ContentLength is too large.
			// If reading fails *during* the stream due to limit, this handler sees error.
			log.Printf("Error reading body: %v", err)
			// Check if it was a MaxBytesError (though http package might not export it easily)
			// A simple check:
			if r.ContentLength == -1 { // If ContentLength wasn't known beforehand
				// Assume error might be due to limit exceeded during read
				// The http.MaxBytesReader already wrote the 413 error response
				return
			}
			// Otherwise, handle other potential read errors
			http.Error(w, "Failed to read request body", http.StatusInternalServerError)
			return
		}
		log.Printf("Received %d bytes", len(bodyBytes))
		w.Write([]byte("Upload received successfully."))
	})

	log.Println("Starting server on :8080")
	http.ListenAndServe(":8080", router)
}
// Example request exceeding limit:
// curl -X POST --data-binary @large_file.dat http://localhost:8080/upload
// -&gt; 413 Request Entity Too Large
</code></pre>
<hr />
<h3 id="trailingslashredirectmiddleware"><a class="header" href="#trailingslashredirectmiddleware">TrailingSlashRedirectMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Redirects requests to add or remove a trailing slash from the URL path for consistency.</li>
<li><strong>Configuration:</strong> <code>nova.TrailingSlashRedirectConfig</code>
<ul>
<li><code>AddSlash bool</code>: Enforce trailing slash (defaults to false - removes slash).</li>
<li><code>RedirectCode int</code>: HTTP redirect status code (defaults to 301). Use 308 for POST/PUT etc. to preserve method.</li>
</ul>
</li>
</ul>
<h4 id="example-15"><a class="header" href="#example-15">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Trailing Slash middleware globally (usually early)
	router.Use(nova.TrailingSlashRedirectMiddleware(nova.TrailingSlashRedirectConfig{
		AddSlash:     false, // Default: remove trailing slash
		RedirectCode: http.StatusMovedPermanently, // Default: 301
		// Or to enforce slashes:
		// AddSlash: true,
		// RedirectCode: http.StatusPermanentRedirect, // 308 to preserve method
	}))

	// Define routes WITHOUT the trailing slash (if AddSlash is false)
	router.Get("/users", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("List of users"))
	})
	router.Get("/products", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("List of products"))
	})
}
// Example request:
// curl -L http://localhost:8080/users/
// -&gt; Redirects (301) to http://localhost:8080/users
// -&gt; Responds with "List of users"
</code></pre>
<hr />
<h3 id="forcehttpsmiddleware"><a class="header" href="#forcehttpsmiddleware">ForceHTTPSMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Redirects incoming HTTP requests to their HTTPS equivalent.</li>
<li><strong>Configuration:</strong> <code>nova.ForceHTTPSConfig</code>
<ul>
<li><code>TargetHost string</code>: Override host in redirect URL (defaults to request host).</li>
<li><code>TargetPort int</code>: Override port in redirect URL (defaults to standard 443).</li>
<li><code>RedirectCode int</code>: Redirect status code (defaults to 301).</li>
<li><code>ForwardedProtoHeader string</code>: Header to check for original protocol (defaults to <code>X-Forwarded-Proto</code>).</li>
<li><code>TrustForwardedHeader *bool</code>: Trust the forwarded header (defaults to true). Set false if proxy doesn’t set it reliably.</li>
</ul>
</li>
</ul>
<h4 id="example-16"><a class="header" href="#example-16">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Force HTTPS middleware globally (very early)
	trustHeader := true
	router.Use(nova.ForceHTTPSMiddleware(nova.ForceHTTPSConfig{
		// RedirectCode: http.StatusPermanentRedirect, // Use 308 if needed
		// ForwardedProtoHeader: "X-Scheme", // If your proxy uses a different header
		TrustForwardedHeader: &amp;trustHeader, // Default is true
	}))

	// Add other middleware like HSTS *after* ForceHTTPS potentially
	router.Use(nova.SecurityHeadersMiddleware(nova.SecurityHeadersConfig{
		HSTSMaxAgeSeconds: 31536000, // Example: 1 year HSTS
	}))

	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Welcome to the secure site!"))
	})
}
// Example request:
// curl http://localhost:8080
// -&gt; Redirects (301) to https://localhost:8080 (or https://localhost if port 443)
</code></pre>
<hr />
<h3 id="concurrencylimitermiddleware"><a class="header" href="#concurrencylimitermiddleware">ConcurrencyLimiterMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Limits the number of requests processed concurrently using a semaphore.</li>
<li><strong>Configuration:</strong> <code>nova.ConcurrencyLimiterConfig</code>
<ul>
<li><code>MaxConcurrent int</code>: Max concurrent requests (required).</li>
<li><code>WaitTimeout time.Duration</code>: Max time to wait for a slot (0 = wait forever).</li>
<li><code>OnLimitExceeded func(w http.ResponseWriter, r *http.Request)</code>: Custom handler for limit exceeded (defaults to 503).</li>
</ul>
</li>
</ul>
<h4 id="example-17"><a class="header" href="#example-17">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Concurrency Limiter middleware globally or to heavy routes
	router.Use(nova.ConcurrencyLimiterMiddleware(nova.ConcurrencyLimiterConfig{
		MaxConcurrent: 10, // Allow only 10 requests at a time
		WaitTimeout:   2 * time.Second, // Wait max 2s for a slot
		// OnLimitExceeded: func(w http.ResponseWriter, r *http.Request) {
		// 	http.Error(w, "Too busy, try later", http.StatusServiceUnavailable)
		// }, // Optional custom handler
	}))

	router.Get("/process", func(w http.ResponseWriter, r *http.Request) {
		log.Println("Processing request...")
		time.Sleep(5 * time.Second) // Simulate work
		log.Println("Finished processing.")
		w.Write([]byte("Processing complete."))
	})
}
// Example: Run 15 concurrent requests:
// for i in {1..15}; do curl http://localhost:8080/process &amp; done
// -&gt; First 10 start immediately, next ~5 wait up to 2s. Some might get 503.
</code></pre>
<hr />
<h3 id="maintenancemodemiddleware"><a class="header" href="#maintenancemodemiddleware">MaintenanceModeMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Returns 503 Service Unavailable if enabled via an atomic flag, allowing bypass for specified IPs/CIDRs.</li>
<li><strong>Configuration:</strong> <code>nova.MaintenanceModeConfig</code>
<ul>
<li><code>EnabledFlag *atomic.Bool</code>: Pointer to the control flag (required).</li>
<li><code>AllowedIPs []string</code>: IPs/CIDRs that bypass maintenance (e.g., <code>["192.168.1.100", "10.0.0.0/8"]</code>).</li>
<li><code>StatusCode int</code>: Status code during maintenance (defaults to 503).</li>
<li><code>RetryAfterSeconds int</code>: Value for <code>Retry-After</code> header (defaults to 300).</li>
<li><code>Message string</code>: Response body during maintenance.</li>
<li><code>Logger *log.Logger</code>: Logger for errors (defaults to <code>log.Default()</code>).</li>
</ul>
</li>
</ul>
<h4 id="example-18"><a class="header" href="#example-18">Example</a></h4>
<pre><code class="language-go">var maintenanceEnabled atomic.Bool // The control flag

func main() {
	router := nova.NewRouter()

	// Set initial state (e.g., false = not in maintenance)
	maintenanceEnabled.Store(false)

	// Apply Maintenance Mode middleware globally (very early)
	router.Use(nova.MaintenanceModeMiddleware(nova.MaintenanceModeConfig{
		EnabledFlag:       &amp;maintenanceEnabled,
		AllowedIPs:        []string{"127.0.0.1", "::1"}, // Allow localhost bypass
		RetryAfterSeconds: 600,                          // 10 minutes
		Message:           "Down for scheduled maintenance. Please try again later.",
	}))

	// Example route to toggle maintenance mode (in real app, use signals or admin API)
	router.Get("/admin/maintenance/on", func(w http.ResponseWriter, r *http.Request) {
		maintenanceEnabled.Store(true)
		w.Write([]byte("Maintenance mode ENABLED"))
		log.Println("Maintenance mode ENABLED")
	})
	router.Get("/admin/maintenance/off", func(w http.ResponseWriter, r *http.Request) {
		maintenanceEnabled.Store(false)
		w.Write([]byte("Maintenance mode DISABLED"))
		log.Println("Maintenance mode DISABLED")
	})

	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Application is running normally."))
	})
}
// Example:
// curl http://localhost:8080/ -&gt; Shows normal page
// curl http://localhost:8080/admin/maintenance/on -&gt; Enables maintenance
// curl http://&lt;your_external_ip&gt;:8080/ -&gt; Shows 503 maintenance page
// curl http://localhost:8080/ -&gt; Still shows normal page (due to AllowedIPs)
// curl http://localhost:8080/admin/maintenance/off -&gt; Disables maintenance
</code></pre>
<hr />
<h3 id="ipfiltermiddleware"><a class="header" href="#ipfiltermiddleware">IPFilterMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Restricts access based on client IP using allow/block lists (CIDR supported).</li>
<li><strong>Configuration:</strong> <code>nova.IPFilterConfig</code>
<ul>
<li><code>AllowedIPs []string</code>: Allowed IPs/CIDRs.</li>
<li><code>BlockedIPs []string</code>: Blocked IPs/CIDRs (takes precedence).</li>
<li><code>BlockByDefault bool</code>: Block IPs not matching any list (defaults to false - allow unless blocked).</li>
<li><code>OnForbidden func(w http.ResponseWriter, r *http.Request)</code>: Custom handler for forbidden IPs (defaults to 403).</li>
<li><code>Logger *log.Logger</code>: Logger for errors (defaults to <code>log.Default()</code>).</li>
</ul>
</li>
</ul>
<h4 id="example-19"><a class="header" href="#example-19">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply IP Filter middleware globally or to specific areas
	router.Use(nova.IPFilterMiddleware(nova.IPFilterConfig{
		// Example 1: Allow only specific IPs/ranges
		// AllowedIPs:     []string{"192.168.1.0/24", "10.0.0.5"},
		// BlockByDefault: true, // Block anything not in AllowedIPs

		// Example 2: Block specific IPs, allow others
		BlockedIPs:     []string{"1.2.3.4", "5.6.7.0/24"},
		BlockByDefault: false, // Default: Allow unless explicitly blocked

		// OnForbidden: func(w http.ResponseWriter, r *http.Request) {
		// 	http.Error(w, "Access denied from your IP.", http.StatusForbidden)
		// }, // Optional custom handler
	}))

	router.Get("/sensitive-data", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("This is sensitive information."))
	})
}
</code></pre>
<hr />
<h3 id="ratelimitmiddleware"><a class="header" href="#ratelimitmiddleware">RateLimitMiddleware</a></h3>
<ul>
<li><strong>Description:</strong> Simple in-memory rate limiting using a token bucket algorithm per client IP (by default). <strong>Warning:</strong> Basic, single-instance only, potential memory growth without cleanup.</li>
<li><strong>Configuration:</strong> <code>nova.RateLimiterConfig</code>
<ul>
<li><code>Requests int</code>: Max requests per duration (required).</li>
<li><code>Duration time.Duration</code>: Time window (required).</li>
<li><code>Burst int</code>: Allowed burst size (defaults to <code>Requests</code>).</li>
<li><code>KeyFunc func(r *http.Request) string</code>: Function to get client key (defaults to IP).</li>
<li><code>OnLimitExceeded func(w http.ResponseWriter, r *http.Request)</code>: Custom handler for limit (defaults to 429).</li>
<li><code>CleanupInterval time.Duration</code>: How often to clean old entries (0 = no cleanup).</li>
<li><code>Logger *log.Logger</code>: Logger for errors (defaults to <code>log.Default()</code>).</li>
</ul>
</li>
</ul>
<h4 id="example-20"><a class="header" href="#example-20">Example</a></h4>
<pre><code class="language-go">func main() {
	router := nova.NewRouter()

	// Apply Rate Limiter middleware globally or to specific APIs
	router.Use(nova.RateLimitMiddleware(nova.RateLimiterConfig{
		Requests: 5,               // Allow 5 requests...
		Duration: 1 * time.Minute, // ...per minute
		Burst:    10,              // Allow initial burst of 10 requests
		// KeyFunc: func(r *http.Request) string { // Optional: Limit by API key header
		// 	key := r.Header.Get("X-API-Key")
		// 	if key == "" { return r.RemoteAddr } // Fallback to IP if no key
		// 	return key
		// },
		CleanupInterval: 10 * time.Minute, // Clean up old entries every 10 mins
		// OnLimitExceeded: func(w http.ResponseWriter, r *http.Request) {
		// 	w.WriteHeader(http.StatusTooManyRequests)
		// 	w.Write([]byte("Rate limit exceeded. Please try again later."))
		// }, // Optional custom handler
	}))

	router.Get("/api/resource", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Resource data"))
	})
}
// Example: Hit the endpoint repeatedly
// for i in {1..15}; do curl -I http://localhost:8080/api/resource; sleep 0.1; done
// -&gt; First ~10 requests get 200 OK, subsequent ones get 429 Too Many Requests
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="openapi.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next prefetch" href="design.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="openapi.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next prefetch" href="design.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>


    </div>
</body>

</html>